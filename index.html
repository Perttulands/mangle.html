<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mangle â€” Visual HTML Editor</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* =========================================================================
           MANGLE.HTML - Premium Design System
           Inspired by Linear, Figma, Raycast
           ========================================================================= */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* === SPACING SCALE (8px grid) === */
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 20px;
            --space-6: 24px;
            --space-8: 32px;
            --space-10: 40px;
            --space-12: 48px;
            --space-16: 64px;

            /* === TYPOGRAPHY === */
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --font-mono: 'SF Mono', 'Fira Code', 'Monaco', monospace;

            --text-xs: 11px;
            --text-sm: 13px;
            --text-base: 14px;
            --text-lg: 16px;
            --text-xl: 20px;
            --text-2xl: 24px;
            --text-3xl: 32px;
            --text-4xl: 40px;

            /* === BORDER RADIUS === */
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;
            --radius-xl: 12px;
            --radius-2xl: 16px;
            --radius-full: 9999px;

            /* === TRANSITIONS === */
            --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-base: 200ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 300ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-spring: 400ms cubic-bezier(0.34, 1.56, 0.64, 1);

            /* === PREMIUM DARK PALETTE === */
            --gray-50: #fafafa;
            --gray-100: #f4f4f5;
            --gray-200: #e4e4e7;
            --gray-300: #d4d4d8;
            --gray-400: #a1a1aa;
            --gray-500: #71717a;
            --gray-600: #52525b;
            --gray-700: #3f3f46;
            --gray-800: #27272a;
            --gray-850: #1f1f23;
            --gray-900: #18181b;
            --gray-950: #09090b;

            /* Accent - Electric Violet */
            --accent-50: #f5f3ff;
            --accent-100: #ede9fe;
            --accent-200: #ddd6fe;
            --accent-300: #c4b5fd;
            --accent-400: #a78bfa;
            --accent-500: #8b5cf6;
            --accent-600: #7c3aed;
            --accent-700: #6d28d9;

            /* Success */
            --success-500: #22c55e;
            --success-600: #16a34a;

            /* Warning */
            --warning-500: #f59e0b;

            /* Error */
            --error-500: #ef4444;
            --error-600: #dc2626;

            /* === SEMANTIC TOKENS (Dark Mode) === */
            --bg-base: var(--gray-950);
            --bg-elevated: var(--gray-900);
            --bg-surface: var(--gray-850);
            --bg-muted: var(--gray-800);
            --bg-subtle: rgba(255, 255, 255, 0.03);
            --bg-hover: rgba(255, 255, 255, 0.05);
            --bg-active: rgba(255, 255, 255, 0.08);

            --text: var(--gray-50);
            --text-secondary: var(--gray-400);
            --text-muted: var(--gray-500);
            --text-placeholder: var(--gray-600);

            --border-subtle: rgba(255, 255, 255, 0.06);
            --border-default: rgba(255, 255, 255, 0.1);
            --border-strong: rgba(255, 255, 255, 0.15);

            --accent: var(--accent-500);
            --accent-hover: var(--accent-400);
            --accent-muted: rgba(139, 92, 246, 0.15);
            --accent-subtle: rgba(139, 92, 246, 0.08);

            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.5);
            --shadow-xl: 0 16px 48px rgba(0, 0, 0, 0.6);
            --shadow-glow: 0 0 20px rgba(139, 92, 246, 0.3);

            --canvas-bg: var(--gray-900);
        }

        /* === LIGHT MODE === */
        [data-theme="light"] {
            --bg-base: var(--gray-50);
            --bg-elevated: #ffffff;
            --bg-surface: var(--gray-100);
            --bg-muted: var(--gray-200);
            --bg-subtle: rgba(0, 0, 0, 0.02);
            --bg-hover: rgba(0, 0, 0, 0.04);
            --bg-active: rgba(0, 0, 0, 0.06);

            --text: var(--gray-900);
            --text-secondary: var(--gray-600);
            --text-muted: var(--gray-500);
            --text-placeholder: var(--gray-400);

            --border-subtle: rgba(0, 0, 0, 0.04);
            --border-default: rgba(0, 0, 0, 0.08);
            --border-strong: rgba(0, 0, 0, 0.12);

            --accent-muted: rgba(139, 92, 246, 0.1);
            --accent-subtle: rgba(139, 92, 246, 0.05);

            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.08);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.12);
            --shadow-xl: 0 16px 48px rgba(0, 0, 0, 0.16);
            --shadow-glow: 0 0 20px rgba(139, 92, 246, 0.15);

            --canvas-bg: var(--gray-200);
        }

        /* === BASE === */
        body {
            font-family: var(--font-sans);
            font-size: var(--text-base);
            font-feature-settings: 'cv02', 'cv03', 'cv04', 'cv11';
            background: var(--bg-base);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        ::selection {
            background: var(--accent-muted);
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-strong);
            border-radius: var(--radius-full);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* === LAYOUT === */
        .app {
            display: grid;
            grid-template-columns: 200px 1fr 240px;
            grid-template-rows: 56px 1fr;
            height: 100vh;
            transition: grid-template-columns 0.3s ease;
        }

        /* Preview mode - full width canvas, hide sidebars */
        .app.preview-mode {
            grid-template-columns: 0 1fr 0;
        }

        .app.preview-mode .sidebar-left,
        .app.preview-mode .sidebar-right {
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
        }

        /* === TOOLBAR === */
        .toolbar {
            grid-column: 1 / -1;
            background: var(--bg-elevated);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            align-items: center;
            padding: 0 var(--space-4);
            gap: var(--space-2);
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: var(--space-1);
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: var(--border-default);
            margin: 0 var(--space-2);
        }

        .toolbar-brand {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            margin-right: var(--space-4);
            padding-right: var(--space-4);
            border-right: 1px solid var(--border-subtle);
        }

        .toolbar-logo {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, var(--accent-500), var(--accent-400));
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            box-shadow: var(--shadow-sm), inset 0 1px 0 rgba(255,255,255,0.1);
        }

        .toolbar-title {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--text);
            letter-spacing: -0.01em;
        }

        /* === BUTTONS === */
        .btn {
            background: var(--bg-subtle);
            border: 1px solid var(--border-subtle);
            color: var(--text);
            padding: var(--space-2) var(--space-3);
            border-radius: var(--radius-md);
            cursor: pointer;
            font-family: var(--font-sans);
            font-size: var(--text-sm);
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            transition: all var(--transition-fast);
            white-space: nowrap;
        }

        .btn:hover {
            background: var(--bg-hover);
            border-color: var(--border-default);
        }

        .btn:active {
            background: var(--bg-active);
            transform: scale(0.98);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        .btn:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }

        .btn-primary {
            background: linear-gradient(180deg, var(--accent-500), var(--accent-600));
            border-color: var(--accent-600);
            color: white;
            box-shadow: var(--shadow-sm), inset 0 1px 0 rgba(255,255,255,0.15);
        }

        .btn-primary:hover {
            background: linear-gradient(180deg, var(--accent-400), var(--accent-500));
            box-shadow: var(--shadow-md), inset 0 1px 0 rgba(255,255,255,0.15);
        }

        .btn-ghost {
            background: transparent;
            border-color: transparent;
        }

        .btn-ghost:hover {
            background: var(--bg-hover);
            border-color: transparent;
        }

        .btn-icon {
            padding: var(--space-2);
            min-width: 32px;
            justify-content: center;
        }

        .btn-sm {
            padding: var(--space-1) var(--space-2);
            font-size: var(--text-xs);
        }

        /* === DROPDOWNS === */
        .dropdown {
            position: relative;
        }

        .dropdown-menu {
            position: absolute;
            top: calc(100% + var(--space-1));
            left: 0;
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-lg);
            min-width: 180px;
            box-shadow: var(--shadow-lg);
            z-index: 100;
            display: none;
            max-height: 400px;
            overflow-y: auto;
            padding: var(--space-1);
            animation: dropdown-in var(--transition-fast) ease-out;
        }

        @keyframes dropdown-in {
            from { opacity: 0; transform: translateY(-4px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .dropdown-menu.open {
            display: block;
        }

        .dropdown-section {
            padding: var(--space-1) 0;
        }

        .dropdown-section + .dropdown-section {
            border-top: 1px solid var(--border-subtle);
            margin-top: var(--space-1);
            padding-top: var(--space-2);
        }

        .dropdown-section-title {
            padding: var(--space-1) var(--space-3);
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
        }

        .dropdown-item {
            padding: var(--space-2) var(--space-3);
            cursor: pointer;
            font-size: var(--text-sm);
            display: flex;
            align-items: center;
            gap: var(--space-2);
            border-radius: var(--radius-md);
            transition: all var(--transition-fast);
            color: var(--text);
        }

        .dropdown-item:hover {
            background: var(--bg-hover);
        }

        .dropdown-item:active {
            background: var(--bg-active);
        }

        .dropdown-item-icon {
            width: 20px;
            text-align: center;
            color: var(--text-secondary);
            font-size: var(--text-sm);
        }

        /* === ZOOM CONTROLS === */
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: var(--space-1);
            background: var(--bg-subtle);
            border-radius: var(--radius-md);
            padding: var(--space-1);
        }

        .zoom-level {
            font-size: var(--text-xs);
            font-weight: 500;
            color: var(--text-secondary);
            min-width: 48px;
            text-align: center;
            cursor: pointer;
            padding: var(--space-1) var(--space-2);
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
        }

        .zoom-level:hover {
            background: var(--bg-hover);
            color: var(--text);
        }

        /* === SIDEBARS === */
        .sidebar-left {
            background: var(--bg-elevated);
            border-right: 1px solid var(--border-subtle);
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: var(--space-4);
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border-subtle);
            flex-shrink: 0;
        }

        /* === TREE SEARCH === */
        .tree-search {
            padding: var(--space-3);
            border-bottom: 1px solid var(--border-subtle);
            flex-shrink: 0;
        }

        .tree-search-input {
            width: 100%;
            padding: var(--space-2) var(--space-3);
            padding-left: 36px;
            background: var(--bg-muted);
            border: 1px solid transparent;
            border-radius: var(--radius-md);
            color: var(--text);
            font-family: var(--font-sans);
            font-size: var(--text-sm);
            outline: none;
            transition: all var(--transition-fast);
        }

        .tree-search-input:hover {
            background: var(--bg-surface);
        }

        .tree-search-input:focus {
            background: var(--bg-surface);
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-subtle);
        }

        .tree-search-input::placeholder {
            color: var(--text-placeholder);
        }

        .tree-search-wrapper {
            position: relative;
        }

        .tree-search-icon {
            position: absolute;
            left: var(--space-3);
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
            font-size: var(--text-sm);
            pointer-events: none;
        }

        .tree-search-clear {
            position: absolute;
            right: var(--space-2);
            top: 50%;
            transform: translateY(-50%);
            background: var(--bg-muted);
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            width: 20px;
            height: 20px;
            border-radius: var(--radius-sm);
            font-size: var(--text-sm);
            display: none;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }

        .tree-search-clear:hover {
            background: var(--bg-active);
            color: var(--text);
        }

        .tree-search-wrapper.has-value .tree-search-clear {
            display: flex;
        }

        .tree-node.search-hidden {
            display: none;
        }

        .tree-node.search-match {
            background: var(--accent-subtle);
        }

        .tree-node.search-match .tree-node-highlight {
            background: var(--accent);
            color: white;
            padding: 1px 4px;
            border-radius: var(--radius-sm);
            font-weight: 500;
        }

        .tree-search-count {
            font-size: var(--text-xs);
            color: var(--text-muted);
            padding: var(--space-2) var(--space-4);
            border-bottom: 1px solid var(--border-subtle);
            display: none;
            background: var(--bg-subtle);
        }

        .tree-search-count.visible {
            display: block;
        }

        /* Search mode toggle */
        .search-mode-toggle {
            display: flex;
            gap: 2px;
            padding: var(--space-1) var(--space-3);
            background: var(--bg-muted);
            border-radius: var(--radius-md);
            margin: 0 var(--space-3) var(--space-2);
        }

        .search-mode-btn {
            flex: 1;
            padding: var(--space-1) var(--space-2);
            font-size: var(--text-xs);
            font-weight: 500;
            color: var(--text-muted);
            background: transparent;
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .search-mode-btn:hover {
            color: var(--text-secondary);
        }

        .search-mode-btn.active {
            background: var(--bg-elevated);
            color: var(--text);
            box-shadow: var(--shadow-sm);
        }

        /* Text search results */
        .text-search-results {
            flex: 1;
            overflow-y: auto;
            display: none;
        }

        .text-search-results.visible {
            display: block;
        }

        .text-search-result {
            padding: var(--space-2) var(--space-4);
            cursor: pointer;
            font-size: var(--text-sm);
            border-bottom: 1px solid var(--border-subtle);
            transition: background var(--transition-fast);
        }

        .text-search-result:hover {
            background: var(--bg-hover);
        }

        .text-search-result:last-child {
            border-bottom: none;
        }

        .text-search-result-tag {
            font-size: var(--text-xs);
            color: var(--text-muted);
            font-family: var(--font-mono);
            margin-bottom: 2px;
        }

        .text-search-result-text {
            color: var(--text);
            word-break: break-word;
        }

        .text-search-result-text mark {
            background: rgba(251, 191, 36, 0.4);
            color: inherit;
            border-radius: 2px;
            padding: 0 2px;
        }

        .text-search-empty {
            padding: var(--space-4);
            color: var(--text-muted);
            text-align: center;
            font-size: var(--text-sm);
        }

        .text-search-hint {
            padding: var(--space-4);
            color: var(--text-muted);
            text-align: center;
            font-size: var(--text-sm);
        }

        /* === ELEMENT TREE === */
        .element-tree {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-2) 0;
        }

        .tree-node {
            padding: var(--space-2) var(--space-4);
            cursor: pointer;
            font-size: var(--text-sm);
            display: flex;
            align-items: center;
            gap: var(--space-2);
            position: relative;
            user-select: none;
            transition: background var(--transition-fast);
            margin: 0 var(--space-2);
            border-radius: var(--radius-md);
            min-width: 0; /* Allow flex children to shrink */
        }

        .tree-node > span:last-child {
            /* Label truncation - no wrapping */
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .tree-node:hover {
            background: var(--bg-hover);
        }

        .tree-node.selected {
            background: var(--accent-muted);
            color: var(--accent-hover);
        }

        .tree-node.dragging {
            opacity: 0.5;
        }

        .tree-node.cloning {
            opacity: 0.8;
            background: rgba(34, 197, 94, 0.15);
        }

        .tree-node.drag-over-before::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            height: 2px;
            border-radius: 1px;
            background: var(--accent);
        }

        .tree-node.drag-over-after::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 2px;
            border-radius: 1px;
            background: var(--accent);
        }

        .tree-node.drag-over-inside {
            background: var(--accent-muted);
            outline: 1px dashed var(--accent);
            outline-offset: -1px;
        }

        .tree-node.clone-target::before {
            content: '+';
            position: absolute;
            left: var(--space-2);
            top: 50%;
            transform: translateY(-50%);
            color: var(--success-500);
            font-weight: 700;
            font-size: var(--text-sm);
        }

        .tree-node-icon {
            color: var(--text-muted);
            font-size: var(--text-xs);
            width: 16px;
            text-align: center;
            flex-shrink: 0;
        }

        .tree-node-indent {
            display: inline-block;
        }

        .tree-content {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            will-change: transform;
        }

        /* === CANVAS AREA === */
        .canvas-area {
            background: var(--canvas-bg);
            overflow: hidden;
            position: relative;
            /* Subtle dot pattern */
            background-image: radial-gradient(var(--border-subtle) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .canvas-area.panning {
            cursor: grab;
        }

        .canvas-area.panning:active {
            cursor: grabbing;
        }

        .canvas-viewport {
            position: absolute;
            inset: 0;
            overflow: hidden;
        }

        .canvas-transform {
            position: absolute;
            transform-origin: 0 0;
            will-change: transform;
            transition: transform 0.15s ease-out;
        }

        .canvas-transform.no-transition {
            transition: none;
        }

        .canvas-wrapper {
            background: white;
            box-shadow: var(--shadow-xl);
            border-radius: var(--radius-lg);
            overflow: hidden;
            position: relative;
            transition: width var(--transition-slow), height var(--transition-slow);
        }

        /* === FIRST-TIME TOOLTIP === */
        .first-time-tooltip {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            pointer-events: none;
            animation: tooltipFadeIn 0.3s ease-out;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 280px;
        }
        .first-time-tooltip::after {
            content: 'Click anywhere to dismiss';
            display: block;
            font-size: 11px;
            opacity: 0.6;
            margin-top: 6px;
        }
        @keyframes tooltipFadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        @keyframes tooltipFadeOut {
            from { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            to { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
        }
        .first-time-tooltip.hiding {
            animation: tooltipFadeOut 0.2s ease-in forwards;
        }

        /* === DEVICE FRAMES === */
        .device-frame {
            position: relative;
            padding: var(--space-3);
            background: var(--gray-900);
            border-radius: var(--radius-2xl);
            box-shadow: var(--shadow-xl), inset 0 1px 0 rgba(255,255,255,0.05);
        }

        .device-frame::before {
            content: '';
            position: absolute;
            top: 6px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 4px;
            background: #333;
            border-radius: 2px;
        }

        .device-frame.phone {
            border-radius: 28px;
            padding: 40px 8px 24px;
        }

        .device-frame.phone::before {
            top: 12px;
            width: 40px;
        }

        .device-frame.phone::after {
            content: '';
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 36px;
            height: 4px;
            background: #333;
            border-radius: 2px;
        }

        .device-frame.tablet {
            border-radius: 16px;
            padding: 24px 12px;
        }

        .device-frame.desktop {
            border-radius: 8px 8px 0 0;
            padding: 24px 4px 4px;
        }

        .device-frame.desktop::after {
            content: '';
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 20px;
            background: linear-gradient(to bottom, #1a1a1a, #333);
            border-radius: 0 0 4px 4px;
        }

        .device-frame.fullwidth {
            padding: 0;
            background: none;
            border-radius: 0;
            box-shadow: none;
        }

        .device-frame.fullwidth::before,
        .device-frame.fullwidth::after {
            display: none;
        }

        /* Viewport selector */
        .viewport-selector {
            display: flex;
            align-items: center;
            gap: 4px;
            background: var(--bg-input);
            border-radius: 4px;
            padding: 2px;
        }

        .viewport-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.15s;
        }

        .viewport-btn:hover {
            background: var(--bg-panel);
            color: var(--text-primary);
        }

        .viewport-btn.active {
            background: var(--accent);
            color: white;
        }

        .viewport-size {
            font-size: 11px;
            color: var(--text-secondary);
            padding: 0 8px;
            min-width: 60px;
            text-align: center;
        }

        /* Grid Overlay */
        .grid-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .grid-overlay.visible {
            opacity: 1;
        }

        .grid-overlay svg {
            width: 100%;
            height: 100%;
        }

        /* Alignment Guide Lines */
        .guide-line {
            position: absolute;
            background: #ff4081;
            pointer-events: none;
            z-index: 1001;
        }

        .guide-line.horizontal {
            height: 1px;
            left: 0;
            right: 0;
        }

        .guide-line.vertical {
            width: 1px;
            top: 0;
            bottom: 0;
        }

        .guide-line.center {
            background: #00bcd4;
        }

        /* Grid toggle button active state */
        .btn.grid-active {
            background: var(--accent);
            border-color: var(--accent);
        }

        /* Mode Toggle - Premium Design */
        .mode-toggle {
            display: flex;
            align-items: center;
            gap: var(--space-1);
            background: var(--bg-surface);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-lg);
            padding: 2px;
            position: relative;
        }

        .mode-toggle-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-1);
            padding: var(--space-1) var(--space-3);
            border: none;
            border-radius: var(--radius-md);
            background: transparent;
            color: var(--text-secondary);
            font-size: var(--text-sm);
            font-family: var(--font-sans);
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-fast);
            position: relative;
            z-index: 1;
        }

        .mode-toggle-btn:hover {
            color: var(--text-primary);
        }

        .mode-toggle-btn.active {
            color: var(--text-primary);
            background: var(--bg-elevated);
            box-shadow: var(--shadow-sm);
        }

        .mode-toggle-btn svg {
            width: 14px;
            height: 14px;
        }

        .mode-indicator {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-1) var(--space-3);
            background: var(--accent-500);
            color: white;
            border-radius: var(--radius-full);
            font-size: var(--text-xs);
            font-weight: 600;
            letter-spacing: 0.02em;
            text-transform: uppercase;
            animation: pulse-glow 2s ease-in-out infinite;
        }

        .mode-indicator.preview-mode {
            background: linear-gradient(135deg, var(--accent-500), var(--accent-600));
        }

        .mode-indicator.edit-mode {
            background: linear-gradient(135deg, var(--success-500), var(--success-600));
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.4); }
            50% { box-shadow: 0 0 0 4px rgba(139, 92, 246, 0); }
        }

        /* Canvas indicator for preview mode */
        .canvas-wrapper.preview-mode {
            box-shadow: none;
        }

        .canvas-wrapper.preview-mode::before {
            content: 'PREVIEW - Press P to edit';
            position: absolute;
            top: 12px;
            right: 12px;
            left: auto;
            transform: none;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: var(--space-2) var(--space-3);
            border-radius: var(--radius-md);
            font-size: var(--text-xs);
            font-weight: 500;
            white-space: nowrap;
            z-index: 100;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .canvas-wrapper.preview-mode:hover::before {
            opacity: 1;
        }

        /* Hide ALL editing UI in preview mode */
        .canvas-wrapper.preview-mode .resize-overlay,
        .canvas-wrapper.preview-mode .spacing-overlay,
        .canvas-wrapper.preview-mode .grid-overlay,
        .canvas-wrapper.preview-mode #guide-container {
            display: none !important;
        }

        /* =========================================================================
           Quick Actions Toolbar - Floating contextual toolbar
           ========================================================================= */

        .quick-actions {
            position: fixed;
            display: flex;
            align-items: center;
            gap: var(--space-1);
            padding: var(--space-1);
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg), 0 0 0 1px rgba(0,0,0,0.05);
            z-index: 1100;
            opacity: 0;
            visibility: hidden;
            transform: translateY(4px);
            transition: all var(--transition-fast);
            pointer-events: none;
        }

        .quick-actions.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
            pointer-events: auto;
        }

        .quick-actions-divider {
            width: 1px;
            height: 20px;
            background: var(--border-default);
            margin: 0 var(--space-1);
        }

        .qa-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            background: transparent;
            border: none;
            border-radius: var(--radius-md);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 14px;
            transition: all var(--transition-fast);
            position: relative;
        }

        .qa-btn:hover {
            background: var(--bg-hover);
            color: var(--text);
        }

        .qa-btn:active {
            background: var(--bg-active);
            transform: scale(0.95);
        }

        .qa-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .qa-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Tooltip for quick action buttons */
        .qa-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 6px);
            left: 50%;
            transform: translateX(-50%);
            padding: var(--space-1) var(--space-2);
            background: var(--gray-900);
            color: var(--gray-100);
            font-size: var(--text-xs);
            font-weight: 500;
            white-space: nowrap;
            border-radius: var(--radius-md);
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-fast);
            pointer-events: none;
            z-index: 1200;
        }

        .qa-btn:hover::after {
            opacity: 1;
            visibility: visible;
        }

        /* Quick actions dropdown for grouped actions */
        .qa-dropdown {
            position: relative;
        }

        .qa-dropdown-menu {
            position: absolute;
            top: calc(100% + 4px);
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-lg);
            padding: var(--space-1);
            min-width: 140px;
            box-shadow: var(--shadow-lg);
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-fast);
            z-index: 1200;
        }

        .qa-dropdown.open .qa-dropdown-menu {
            opacity: 1;
            visibility: visible;
        }

        .qa-dropdown-item {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            border-radius: var(--radius-md);
            color: var(--text);
            font-size: var(--text-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .qa-dropdown-item:hover {
            background: var(--bg-hover);
        }

        .qa-dropdown-item-icon {
            width: 16px;
            text-align: center;
            color: var(--text-secondary);
        }

        /* Element-specific action groups */
        .qa-group {
            display: flex;
            align-items: center;
            gap: var(--space-1);
        }

        .qa-group.hidden {
            display: none;
        }

        .canvas-wrapper iframe {
            border: none;
            display: block;
        }

        .canvas-wrapper.hidden {
            display: none;
        }

        /* === RESIZE HANDLES OVERLAY === */
        .resize-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }

        .resize-overlay.active {
            display: block;
        }

        .resize-box {
            position: absolute;
            border: 2px solid var(--accent-500);
            pointer-events: none;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
        }

        .resize-box.constrained {
            border-style: dashed;
            border-color: var(--warning-500);
        }

        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: white;
            border: 2px solid var(--accent-500);
            border-radius: 2px;
            pointer-events: all;
            z-index: 10;
            transition: transform var(--transition-fast), background var(--transition-fast);
        }

        .resize-handle:hover {
            transform: scale(1.2);
            background: var(--accent-100);
        }

        .resize-handle:active {
            background: var(--accent-200);
        }

        .resize-handle.constrained {
            border-color: var(--warning-500);
            background: var(--warning-500);
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Corner handles */
        .resize-handle.nw { top: -5px; left: -5px; cursor: nwse-resize; }
        .resize-handle.n { top: -5px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .resize-handle.ne { top: -5px; right: -5px; cursor: nesw-resize; }
        .resize-handle.e { top: 50%; right: -5px; transform: translateY(-50%); cursor: ew-resize; }
        .resize-handle.se { bottom: -5px; right: -5px; cursor: nwse-resize; }
        .resize-handle.s { bottom: -5px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .resize-handle.sw { bottom: -5px; left: -5px; cursor: nesw-resize; }
        .resize-handle.w { top: 50%; left: -5px; transform: translateY(-50%); cursor: ew-resize; }

        .resize-handle.n:hover, .resize-handle.s:hover { transform: translateX(-50%) scale(1.2); }
        .resize-handle.e:hover, .resize-handle.w:hover { transform: translateY(-50%) scale(1.2); }

        /* Dimension label */
        .resize-dimensions {
            position: absolute;
            bottom: -28px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--gray-900);
            color: white;
            font-size: var(--text-xs);
            font-family: var(--font-mono);
            padding: 4px 8px;
            border-radius: var(--radius-sm);
            white-space: nowrap;
            pointer-events: none;
            box-shadow: var(--shadow-md);
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .resize-overlay.resizing .resize-dimensions,
        .resize-overlay.moving .resize-dimensions {
            opacity: 1;
        }

        /* Constraint tooltip */
        .constraint-tooltip {
            position: absolute;
            top: -36px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--warning-500);
            color: var(--gray-900);
            font-size: var(--text-xs);
            font-weight: 500;
            padding: 4px 10px;
            border-radius: var(--radius-sm);
            white-space: nowrap;
            pointer-events: all;
            cursor: pointer;
            box-shadow: var(--shadow-md);
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .constraint-tooltip::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 50%;
            transform: translateX(-50%);
            border: 4px solid transparent;
            border-top-color: var(--warning-500);
        }

        .resize-box.constrained:hover .constraint-tooltip {
            opacity: 1;
        }

        /* Move cursor for positioned elements */
        .resize-box.movable {
            cursor: move;
            pointer-events: all;
        }

        .resize-box.static-element {
            cursor: default;
        }

        /* Position hint for static elements */
        .position-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: var(--text-xs);
            padding: 6px 12px;
            border-radius: var(--radius-md);
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .resize-box.static-element:hover .position-hint {
            opacity: 0.9;
        }

        /* === SPACING OVERLAY === */
        .spacing-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 999;
            display: none;
        }

        .spacing-overlay.active {
            display: block;
        }

        /* Margin visualization (orange) */
        .spacing-margin {
            position: absolute;
            background: rgba(249, 115, 22, 0.25);
            border: 1px dashed rgba(249, 115, 22, 0.6);
        }

        .spacing-margin-top { top: 0; left: 0; right: 0; }
        .spacing-margin-right { top: 0; right: 0; bottom: 0; }
        .spacing-margin-bottom { bottom: 0; left: 0; right: 0; }
        .spacing-margin-left { top: 0; left: 0; bottom: 0; }

        /* Padding visualization (green) */
        .spacing-padding {
            position: absolute;
            background: rgba(34, 197, 94, 0.25);
            border: 1px dashed rgba(34, 197, 94, 0.6);
        }

        .spacing-padding-top { top: 0; left: 0; right: 0; }
        .spacing-padding-right { top: 0; right: 0; bottom: 0; }
        .spacing-padding-bottom { bottom: 0; left: 0; right: 0; }
        .spacing-padding-left { top: 0; left: 0; bottom: 0; }

        /* Content box (center area) */
        .spacing-content {
            position: absolute;
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.4);
        }

        /* Spacing labels */
        .spacing-label {
            position: absolute;
            font-size: 10px;
            font-family: var(--font-mono);
            font-weight: 600;
            padding: 1px 4px;
            border-radius: 2px;
            pointer-events: none;
            white-space: nowrap;
            z-index: 10;
        }

        .spacing-label.margin-label {
            background: rgba(249, 115, 22, 0.9);
            color: white;
        }

        .spacing-label.padding-label {
            background: rgba(34, 197, 94, 0.9);
            color: white;
        }

        .spacing-label.top { top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .spacing-label.right { top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .spacing-label.bottom { top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .spacing-label.left { top: 50%; left: 50%; transform: translate(-50%, -50%); }

        /* Draggable edges */
        .spacing-edge {
            position: absolute;
            pointer-events: all;
            z-index: 20;
            transition: background var(--transition-fast);
        }

        .spacing-edge:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .spacing-edge.active {
            background: rgba(255, 255, 255, 0.25);
        }

        .spacing-edge.horizontal {
            height: 8px;
            cursor: ns-resize;
            left: 0;
            right: 0;
        }

        .spacing-edge.vertical {
            width: 8px;
            cursor: ew-resize;
            top: 0;
            bottom: 0;
        }

        .spacing-edge.margin-top { top: -4px; }
        .spacing-edge.margin-bottom { bottom: -4px; }
        .spacing-edge.margin-left { left: -4px; }
        .spacing-edge.margin-right { right: -4px; }

        .spacing-edge.padding-top { top: 0; }
        .spacing-edge.padding-bottom { bottom: 0; }
        .spacing-edge.padding-left { left: 0; }
        .spacing-edge.padding-right { right: 0; }

        /* Spacing presets bar */
        .spacing-presets {
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            background: var(--gray-900);
            padding: 4px;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-fast);
        }

        .spacing-overlay.editing .spacing-presets {
            opacity: 1;
            pointer-events: all;
        }

        .spacing-preset {
            padding: 4px 8px;
            font-size: 10px;
            font-family: var(--font-mono);
            font-weight: 500;
            color: var(--text-secondary);
            background: var(--bg-muted);
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .spacing-preset:hover {
            background: var(--accent-muted);
            color: var(--accent);
        }

        .spacing-preset.active {
            background: var(--accent);
            color: white;
        }

        /* Spacing value display while dragging */
        .spacing-drag-value {
            position: fixed;
            background: var(--gray-900);
            color: white;
            font-size: 11px;
            font-family: var(--font-mono);
            padding: 4px 8px;
            border-radius: var(--radius-sm);
            box-shadow: var(--shadow-md);
            pointer-events: none;
            z-index: 10000;
            display: none;
        }

        .spacing-drag-value.visible {
            display: block;
        }

        /* === WELCOME SCREEN === */
        .welcome-screen {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-base);
            color: var(--text);
            z-index: 10;
            padding: var(--space-10);
            overflow-y: auto;
            /* Animated gradient background */
            background:
                radial-gradient(ellipse at 20% 0%, rgba(139, 92, 246, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 100%, rgba(139, 92, 246, 0.1) 0%, transparent 50%),
                var(--bg-base);
        }

        .welcome-screen.hidden {
            display: none;
        }

        .welcome-content {
            max-width: 560px;
            text-align: center;
            animation: welcome-fade-in 0.6s ease-out;
        }

        @keyframes welcome-fade-in {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .welcome-logo {
            width: 80px;
            height: 80px;
            margin: 0 auto var(--space-6);
            background: linear-gradient(135deg, var(--accent-500), var(--accent-400));
            border-radius: var(--radius-xl);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            box-shadow: var(--shadow-lg), var(--shadow-glow);
            animation: welcome-logo-float 3s ease-in-out infinite;
        }

        @keyframes welcome-logo-float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }

        .welcome-title {
            font-size: var(--text-4xl);
            font-weight: 700;
            margin-bottom: var(--space-3);
            background: linear-gradient(135deg, var(--text), var(--accent-400));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.02em;
        }

        .welcome-subtitle {
            font-size: var(--text-lg);
            color: var(--text-secondary);
            margin-bottom: var(--space-10);
            line-height: 1.6;
            max-width: 440px;
            margin-left: auto;
            margin-right: auto;
        }

        /* === DROP ZONE === */
        .drop-zone {
            border: 2px dashed var(--border-default);
            border-radius: var(--radius-2xl);
            padding: var(--space-12) var(--space-8);
            margin-bottom: var(--space-6);
            transition: all var(--transition-base);
            cursor: pointer;
            background: var(--bg-subtle);
            position: relative;
            overflow: hidden;
        }

        .drop-zone::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, var(--accent-subtle), transparent);
            opacity: 0;
            transition: opacity var(--transition-base);
        }

        .drop-zone:hover {
            border-color: var(--accent);
            background: var(--bg-hover);
        }

        .drop-zone:hover::before {
            opacity: 1;
        }

        .drop-zone.dragover {
            border-color: var(--accent);
            background: var(--accent-subtle);
            transform: scale(1.01);
            box-shadow: var(--shadow-glow);
        }

        .drop-zone-icon {
            font-size: 48px;
            margin-bottom: var(--space-4);
            position: relative;
            z-index: 1;
        }

        .drop-zone-text {
            font-size: var(--text-lg);
            font-weight: 600;
            margin-bottom: var(--space-2);
            color: var(--text);
            position: relative;
            z-index: 1;
        }

        .drop-zone-hint {
            font-size: var(--text-sm);
            color: var(--text-muted);
            position: relative;
            z-index: 1;
        }

        .welcome-divider {
            display: flex;
            align-items: center;
            gap: var(--space-4);
            margin: var(--space-6) 0;
            color: var(--text-muted);
            font-size: var(--text-sm);
        }

        .welcome-divider::before,
        .welcome-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border-subtle);
        }

        .btn-sample {
            background: linear-gradient(180deg, var(--accent-500), var(--accent-600));
            color: white;
            border: none;
            padding: var(--space-4) var(--space-8);
            font-family: var(--font-sans);
            font-size: var(--text-base);
            font-weight: 600;
            border-radius: var(--radius-lg);
            cursor: pointer;
            transition: all var(--transition-base);
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            box-shadow: var(--shadow-md), inset 0 1px 0 rgba(255,255,255,0.15);
        }

        .btn-sample:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg), var(--shadow-glow);
        }

        .btn-sample:active {
            transform: translateY(0);
        }

        /* === FEATURE CARDS === */
        .features-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--space-4);
            margin-top: var(--space-10);
            text-align: left;
        }

        .feature-card {
            background: var(--bg-subtle);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-xl);
            padding: var(--space-5);
            transition: all var(--transition-base);
        }

        .feature-card:hover {
            border-color: var(--border-default);
            background: var(--bg-hover);
            transform: translateY(-2px);
        }

        .feature-icon {
            width: 40px;
            height: 40px;
            background: var(--accent-subtle);
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            margin-bottom: var(--space-3);
        }

        .feature-title {
            font-size: var(--text-sm);
            font-weight: 600;
            margin-bottom: var(--space-1);
            color: var(--text);
        }

        .feature-desc {
            font-size: var(--text-xs);
            color: var(--text-secondary);
            line-height: 1.5;
        }

        /* === KEYBOARD HINTS (hidden by default - intimidates non-coders) === */
        .shortcuts-hint {
            display: none; /* Hidden from welcome screen */
        }

        .shortcuts-help-link {
            margin-top: var(--space-8);
            font-size: var(--text-xs);
            color: var(--text-muted);
            text-align: center;
        }

        .shortcuts-help-link a {
            color: var(--text-secondary);
            text-decoration: none;
            cursor: pointer;
        }

        .shortcuts-help-link a:hover {
            color: var(--accent);
        }

        .shortcut-item {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        kbd {
            background: var(--bg-muted);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-sm);
            padding: 2px 6px;
            font-family: var(--font-mono);
            font-size: 10px;
            color: var(--text-secondary);
        }

        /* === SHORTCUTS MODAL === */
        .shortcuts-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-base), visibility var(--transition-base);
        }

        .shortcuts-modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .shortcuts-modal {
            background: var(--bg-elevated);
            border-radius: var(--radius-xl);
            padding: var(--space-6);
            max-width: 480px;
            width: 90%;
            box-shadow: var(--shadow-xl);
            transform: scale(0.95);
            transition: transform var(--transition-base);
        }

        .shortcuts-modal-overlay.visible .shortcuts-modal {
            transform: scale(1);
        }

        .shortcuts-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-4);
        }

        .shortcuts-modal-title {
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--text);
        }

        .shortcuts-modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 20px;
            cursor: pointer;
            padding: var(--space-1);
            line-height: 1;
        }

        .shortcuts-modal-close:hover {
            color: var(--text);
        }

        .shortcuts-list {
            display: grid;
            gap: var(--space-2);
        }

        .shortcut-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-2) 0;
            border-bottom: 1px solid var(--border-subtle);
        }

        .shortcut-row:last-child {
            border-bottom: none;
        }

        .shortcut-action {
            color: var(--text);
            font-size: var(--text-sm);
        }

        .shortcut-keys {
            display: flex;
            gap: var(--space-1);
        }

        .shortcut-keys kbd {
            font-size: 11px;
            padding: 3px 8px;
        }

        /* === CONTEXT MENU === */
        .context-menu {
            position: fixed;
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-lg);
            padding: var(--space-1);
            min-width: 200px;
            box-shadow: var(--shadow-xl);
            z-index: 10000;
            display: none;
            backdrop-filter: blur(8px);
        }

        .context-menu.visible {
            display: block;
            animation: context-menu-in var(--transition-fast) ease-out;
        }

        @keyframes context-menu-in {
            from { opacity: 0; transform: scale(0.96) translateY(-4px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }

        .context-menu-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-2) var(--space-3);
            cursor: pointer;
            font-size: var(--text-sm);
            color: var(--text);
            border-radius: var(--radius-md);
            transition: all var(--transition-fast);
            margin: 1px 0;
        }

        .context-menu-item:hover {
            background: var(--bg-hover);
        }

        .context-menu-item:active {
            background: var(--bg-active);
        }

        .context-menu-item.disabled {
            opacity: 0.4;
            pointer-events: none;
        }

        .context-menu-item-icon {
            width: 20px;
            text-align: center;
            margin-right: var(--space-2);
            font-size: var(--text-sm);
        }

        .context-menu-item-label {
            flex: 1;
        }

        .context-menu-item-shortcut {
            font-size: var(--text-xs);
            color: var(--text-muted);
            margin-left: var(--space-4);
            font-family: var(--font-mono);
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .context-menu-item:hover .context-menu-item-shortcut {
            opacity: 1;
        }

        .context-menu-divider {
            height: 1px;
            background: var(--border-subtle);
            margin: var(--space-1) var(--space-2);
        }

        /* === TOAST NOTIFICATIONS === */
        .toast-container {
            position: fixed;
            bottom: var(--space-6);
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
            pointer-events: none;
        }

        .toast {
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-lg);
            padding: var(--space-3) var(--space-4);
            display: flex;
            align-items: center;
            gap: var(--space-3);
            max-width: 400px;
            box-shadow: var(--shadow-lg);
            animation: toast-in var(--transition-slow) var(--transition-spring);
            pointer-events: auto;
            backdrop-filter: blur(8px);
        }

        .toast.toast-error {
            border-color: var(--error-500);
            background: linear-gradient(135deg, rgba(239,68,68,0.1), var(--bg-elevated));
        }

        .toast.toast-warning {
            border-color: var(--warning-500);
            background: linear-gradient(135deg, rgba(245,158,11,0.1), var(--bg-elevated));
        }

        .toast.toast-info {
            border-color: var(--accent);
            background: linear-gradient(135deg, var(--accent-subtle), var(--bg-elevated));
        }

        .toast.toast-success {
            border-color: var(--success-500);
            background: linear-gradient(135deg, rgba(34,197,94,0.1), var(--bg-elevated));
        }

        .toast-icon {
            font-size: var(--text-lg);
            flex-shrink: 0;
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-weight: 600;
            font-size: var(--text-sm);
            color: var(--text);
        }

        .toast-message {
            font-size: var(--text-xs);
            color: var(--text-secondary);
            margin-top: 2px;
        }

        .toast-close {
            background: var(--bg-subtle);
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: var(--space-1);
            font-size: var(--text-base);
            line-height: 1;
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
        }

        .toast-close:hover {
            background: var(--bg-hover);
            color: var(--text);
        }

        .toast.toast-out {
            animation: toast-out var(--transition-base) ease forwards;
        }

        @keyframes toast-in {
            from { opacity: 0; transform: translateY(16px) scale(0.96); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        @keyframes toast-out {
            from { opacity: 1; transform: translateY(0) scale(1); }
            to { opacity: 0; transform: translateY(8px) scale(0.96); }
        }

        /* === PROPERTIES PANEL === */
        .sidebar-right {
            background: var(--bg-elevated);
            border-left: 1px solid var(--border-subtle);
            overflow-y: auto;
        }

        .property-section {
            border-bottom: 1px solid var(--border-subtle);
            padding: var(--space-4);
        }

        .property-section-title {
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: var(--space-3);
        }

        .property-row {
            display: flex;
            align-items: center;
            margin-bottom: var(--space-2);
        }

        .property-label {
            font-size: var(--text-xs);
            color: var(--text-secondary);
            width: 72px;
            flex-shrink: 0;
        }

        .property-input {
            flex: 1;
            background: var(--bg-muted);
            border: 1px solid transparent;
            color: var(--text);
            padding: var(--space-2) var(--space-3);
            border-radius: var(--radius-md);
            font-family: var(--font-sans);
            font-size: var(--text-sm);
            transition: all var(--transition-fast);
        }

        .property-input:hover {
            background: var(--bg-surface);
        }

        .property-input:focus {
            background: var(--bg-surface);
            border-color: var(--accent);
            outline: none;
            box-shadow: 0 0 0 3px var(--accent-subtle);
        }

        .property-input[type="color"] {
            padding: 2px;
            height: 32px;
            cursor: pointer;
        }

        .property-select {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2371717a' d='M3 4.5L6 7.5L9 4.5'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            padding-right: 28px;
        }

        .property-select:focus {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%238b5cf6' d='M3 4.5L6 7.5L9 4.5'/%3E%3C/svg%3E");
        }

        .property-select option {
            background: var(--bg-elevated);
            color: var(--text);
            padding: var(--space-2);
        }

        .property-textarea {
            width: 100%;
            min-height: 80px;
            resize: vertical;
        }

        .spacing-grid {
            display: grid;
            grid-template-columns: 1fr 50px 1fr;
            gap: 2px;
            margin-top: var(--space-2);
        }

        .spacing-grid input {
            text-align: center;
            padding: var(--space-1);
            font-size: var(--text-xs);
            min-width: 0;
            width: 100%;
        }

        .spacing-grid .center {
            background: var(--bg-subtle);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
            min-height: 28px;
        }

        /* No selection state */
        .no-selection {
            padding: var(--space-8) var(--space-4);
            text-align: center;
            color: var(--text-muted);
            font-size: var(--text-sm);
        }

        /* === UTILITY CLASSES === */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }

        /* === DOCUMENT COLORS PALETTE === */
        .color-picker-wrapper {
            position: relative;
        }

        .color-picker-row {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .color-picker-row .property-input[type="color"] {
            flex-shrink: 0;
        }

        .color-value-display {
            flex: 1;
            font-family: var(--font-mono);
            font-size: var(--text-xs);
            color: var(--text-secondary);
            text-transform: uppercase;
            cursor: pointer;
            padding: var(--space-1) var(--space-2);
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
            background: var(--bg-muted);
        }

        .color-value-display:hover {
            background: var(--bg-hover);
            color: var(--text);
        }

        .apply-all-checkbox {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            margin-top: var(--space-2);
            padding: var(--space-2);
            background: var(--bg-muted);
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: var(--text-xs);
            color: var(--text-secondary);
            transition: all var(--transition-fast);
        }

        .apply-all-checkbox:hover {
            background: var(--bg-hover);
            color: var(--text);
        }

        .apply-all-checkbox input[type="checkbox"] {
            width: 14px;
            height: 14px;
            accent-color: var(--accent);
            cursor: pointer;
        }

        .apply-all-checkbox span {
            user-select: none;
        }

        .document-colors {
            margin-top: var(--space-3);
        }

        .document-colors-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-2);
        }

        .document-colors-label {
            font-size: var(--text-xs);
            color: var(--text-muted);
            font-weight: 500;
        }

        .document-colors-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .doc-color-swatch {
            width: 24px;
            height: 24px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            border: 2px solid transparent;
            transition: all var(--transition-fast);
            position: relative;
        }

        .doc-color-swatch::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: calc(var(--radius-sm) - 2px);
            box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.15), inset 0 0 0 1px rgba(255, 255, 255, 0.1);
            pointer-events: none;
        }

        .doc-color-swatch:hover {
            transform: scale(1.15);
            border-color: var(--accent);
            z-index: 1;
        }

        .doc-color-swatch.active {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px var(--accent-muted);
        }

        .doc-color-swatch-count {
            position: absolute;
            bottom: -4px;
            right: -4px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            font-size: 9px;
            font-weight: 600;
            color: var(--text-secondary);
            padding: 0 3px;
            border-radius: 4px;
            line-height: 1.4;
            min-width: 14px;
            text-align: center;
        }

        /* =========================================================================
           Font Picker
           ========================================================================= */

        .font-picker-wrapper {
            position: relative;
        }

        .font-picker-trigger {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-2) var(--space-3);
            background: var(--bg-muted);
            border: 1px solid transparent;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .font-picker-trigger:hover {
            background: var(--bg-surface);
            border-color: var(--border-default);
        }

        .font-picker-trigger.open {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-subtle);
        }

        .font-picker-preview {
            font-size: var(--text-sm);
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 140px;
        }

        .font-picker-arrow {
            color: var(--text-muted);
            font-size: 10px;
            transition: transform var(--transition-fast);
        }

        .font-picker-trigger.open .font-picker-arrow {
            transform: rotate(180deg);
        }

        .font-picker-dropdown {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            z-index: 100;
            max-height: 320px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-4px);
            transition: all var(--transition-fast);
        }

        .font-picker-dropdown.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .font-picker-search {
            padding: var(--space-2);
            border-bottom: 1px solid var(--border-subtle);
            flex-shrink: 0;
        }

        .font-picker-search-input {
            width: 100%;
            padding: var(--space-2) var(--space-3);
            background: var(--bg-muted);
            border: 1px solid transparent;
            border-radius: var(--radius-md);
            color: var(--text);
            font-family: var(--font-sans);
            font-size: var(--text-sm);
            outline: none;
        }

        .font-picker-search-input:focus {
            border-color: var(--accent);
            background: var(--bg-surface);
        }

        .font-picker-list {
            overflow-y: auto;
            flex: 1;
        }

        .font-picker-section {
            padding: var(--space-1) 0;
        }

        .font-picker-section-title {
            padding: var(--space-1) var(--space-3);
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            position: sticky;
            top: 0;
            background: var(--bg-elevated);
            z-index: 1;
        }

        .font-picker-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-2) var(--space-3);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .font-picker-item:hover {
            background: var(--bg-hover);
        }

        .font-picker-item.active {
            background: var(--accent-subtle);
        }

        .font-picker-item-name {
            font-size: var(--text-sm);
            color: var(--text);
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .font-picker-item-count {
            font-size: var(--text-xs);
            color: var(--text-muted);
            background: var(--bg-muted);
            padding: 2px 6px;
            border-radius: var(--radius-sm);
            margin-left: var(--space-2);
        }

        .font-picker-item-preview {
            font-size: 11px;
            color: var(--text-secondary);
            margin-left: var(--space-2);
        }

        /* Document fonts highlight on hover */
        .font-picker-item[data-has-elements]:hover {
            position: relative;
        }

        .font-picker-no-results {
            padding: var(--space-4);
            text-align: center;
            color: var(--text-muted);
            font-size: var(--text-sm);
        }

        /* Quick weight/style toggles */
        .font-style-toggles {
            display: flex;
            gap: var(--space-1);
            margin-top: var(--space-2);
        }

        .font-style-btn {
            flex: 1;
            padding: var(--space-1) var(--space-2);
            background: var(--bg-muted);
            border: 1px solid transparent;
            border-radius: var(--radius-md);
            color: var(--text-secondary);
            font-size: var(--text-xs);
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .font-style-btn:hover {
            background: var(--bg-surface);
            color: var(--text);
        }

        .font-style-btn.active {
            background: var(--accent-subtle);
            border-color: var(--accent);
            color: var(--accent);
        }

        .font-style-btn-bold {
            font-weight: 700;
        }

        .font-style-btn-italic {
            font-style: italic;
        }

        /* =========================================================================
           Style Clipboard / Eyedropper
           ========================================================================= */

        .style-clipboard-indicator {
            position: fixed;
            bottom: var(--space-4);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-2) var(--space-4);
            background: var(--bg-elevated);
            border: 1px solid var(--accent);
            border-radius: var(--radius-full);
            box-shadow: var(--shadow-lg), 0 0 0 4px var(--accent-subtle);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-fast);
        }

        .style-clipboard-indicator.visible {
            opacity: 1;
            visibility: visible;
        }

        .style-clipboard-icon {
            width: 20px;
            height: 20px;
            background: var(--accent);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
        }

        .style-clipboard-text {
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--text);
        }

        .style-clipboard-hint {
            font-size: var(--text-xs);
            color: var(--text-muted);
        }

        .style-clipboard-clear {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: var(--space-1);
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
        }

        .style-clipboard-clear:hover {
            background: var(--bg-hover);
            color: var(--text);
        }

        /* Eyedropper mode cursor */
        .eyedropper-mode {
            cursor: crosshair !important;
        }

        .eyedropper-mode * {
            cursor: crosshair !important;
        }

        /* Style preview overlay on hover */
        .style-preview-overlay {
            position: fixed;
            padding: var(--space-2) var(--space-3);
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            font-size: var(--text-xs);
            color: var(--text-secondary);
            pointer-events: none;
            z-index: 1100;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-fast);
            max-width: 200px;
        }

        .style-preview-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .style-preview-title {
            font-weight: 600;
            color: var(--text);
            margin-bottom: var(--space-1);
        }

        .style-preview-item {
            display: flex;
            justify-content: space-between;
            gap: var(--space-2);
        }

        .style-preview-prop {
            color: var(--text-muted);
        }

        .style-preview-value {
            color: var(--accent);
            font-family: var(--font-mono);
        }

        .doc-color-actions {
            display: flex;
            gap: var(--space-1);
            margin-top: var(--space-2);
        }

        .btn-replace-color {
            flex: 1;
            font-size: var(--text-xs);
            padding: var(--space-1) var(--space-2);
            background: var(--accent-subtle);
            border: 1px solid var(--accent);
            color: var(--accent);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .btn-replace-color:hover {
            background: var(--accent-muted);
        }

        .btn-replace-color:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Replace Color Modal */
        .color-replace-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-base);
            backdrop-filter: blur(4px);
        }

        .color-replace-modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .color-replace-modal-content {
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-xl);
            padding: var(--space-6);
            max-width: 380px;
            width: 90%;
            box-shadow: var(--shadow-xl);
            transform: scale(0.95) translateY(10px);
            transition: transform var(--transition-base);
        }

        .color-replace-modal.visible .color-replace-modal-content {
            transform: scale(1) translateY(0);
        }

        .color-replace-title {
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--text);
            margin-bottom: var(--space-4);
            text-align: center;
        }

        .color-replace-preview {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-4);
            margin-bottom: var(--space-4);
            padding: var(--space-4);
            background: var(--bg-subtle);
            border-radius: var(--radius-lg);
        }

        .color-replace-swatch {
            width: 56px;
            height: 56px;
            border-radius: var(--radius-md);
            border: 2px solid var(--border-default);
            position: relative;
        }

        .color-replace-swatch-label {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: var(--text-xs);
            color: var(--text-muted);
            white-space: nowrap;
        }

        .color-replace-arrow {
            color: var(--text-muted);
            font-size: var(--text-2xl);
        }

        .color-replace-info {
            text-align: center;
            font-size: var(--text-sm);
            color: var(--text-secondary);
            margin-bottom: var(--space-4);
            padding: var(--space-3);
            background: var(--accent-subtle);
            border-radius: var(--radius-md);
        }

        .color-replace-info strong {
            color: var(--text);
        }

        .color-replace-new-color {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            margin-bottom: var(--space-4);
            padding: var(--space-3);
            background: var(--bg-muted);
            border-radius: var(--radius-md);
        }

        .color-replace-new-color label {
            font-size: var(--text-sm);
            color: var(--text-secondary);
        }

        .color-replace-new-color input[type="color"] {
            width: 48px;
            height: 32px;
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
        }

        .color-replace-new-color .color-value-display {
            flex: 1;
        }

        .color-replace-actions {
            display: flex;
            gap: var(--space-2);
            justify-content: flex-end;
        }

        .color-replace-actions .btn {
            padding: var(--space-2) var(--space-4);
        }

        .no-document-colors {
            font-size: var(--text-xs);
            color: var(--text-muted);
            font-style: italic;
            padding: var(--space-2) 0;
        }
    </style>
</head>
<body>
    <div class="app">
        <!-- Toolbar -->
        <header class="toolbar">
            <div class="toolbar-brand">
                <div class="toolbar-logo">âœ¦</div>
                <span class="toolbar-title">mangle</span>
            </div>

            <div class="toolbar-section">
                <button class="btn" id="btn-open">
                    <span>Open</span>
                </button>
                <input type="file" id="file-input" accept=".html,.htm" class="visually-hidden">
            </div>

            <div class="toolbar-section">
                <div class="dropdown" id="insert-dropdown">
                    <button class="btn" id="btn-insert" disabled>
                        <span>+ Add</span>
                    </button>
                    <div class="dropdown-menu" id="insert-menu">
                        <div class="dropdown-section">
                            <div class="dropdown-section-title">âœ¨ Templates</div>
                            <div class="dropdown-item" data-template="slide"><span class="dropdown-item-icon">ðŸŽ´</span>Slide</div>
                            <div class="dropdown-item" data-template="card"><span class="dropdown-item-icon">ðŸƒ</span>Card</div>
                            <div class="dropdown-item" data-template="hero"><span class="dropdown-item-icon">ðŸ¦¸</span>Hero Section</div>
                            <div class="dropdown-item" data-template="two-column"><span class="dropdown-item-icon">â–¥</span>Two Columns</div>
                            <div class="dropdown-item" data-template="cta"><span class="dropdown-item-icon">ðŸ‘†</span>Call to Action</div>
                        </div>
                        <div class="dropdown-section">
                            <div class="dropdown-section-title">Layout</div>
                            <div class="dropdown-item" data-tag="div"><span class="dropdown-item-icon">ðŸ“¦</span>Container</div>
                            <div class="dropdown-item" data-tag="section"><span class="dropdown-item-icon">ðŸ“„</span>Page Section</div>
                            <div class="dropdown-item" data-tag="header"><span class="dropdown-item-icon">ðŸ”</span>Page Header</div>
                            <div class="dropdown-item" data-tag="footer"><span class="dropdown-item-icon">ðŸ”š</span>Page Footer</div>
                            <div class="dropdown-item" data-tag="nav"><span class="dropdown-item-icon">â˜°</span>Navigation</div>
                        </div>
                        <div class="dropdown-section">
                            <div class="dropdown-section-title">Text</div>
                            <div class="dropdown-item" data-tag="h1"><span class="dropdown-item-icon">ð‡</span>Title</div>
                            <div class="dropdown-item" data-tag="h2"><span class="dropdown-item-icon">ð¡</span>Subtitle</div>
                            <div class="dropdown-item" data-tag="h3"><span class="dropdown-item-icon">H3</span>Heading 3</div>
                            <div class="dropdown-item" data-tag="p"><span class="dropdown-item-icon">Â¶</span>Text Block</div>
                            <div class="dropdown-item" data-tag="span"><span class="dropdown-item-icon">Aa</span>Inline Text</div>
                        </div>
                        <div class="dropdown-section">
                            <div class="dropdown-section-title">Interactive</div>
                            <div class="dropdown-item" data-tag="button"><span class="dropdown-item-icon">ðŸ”˜</span>Button</div>
                            <div class="dropdown-item" data-tag="a"><span class="dropdown-item-icon">ðŸ”—</span>Link</div>
                            <div class="dropdown-item" data-tag="input"><span class="dropdown-item-icon">âœï¸</span>Input Field</div>
                        </div>
                        <div class="dropdown-section">
                            <div class="dropdown-section-title">Media</div>
                            <div class="dropdown-item" data-tag="img"><span class="dropdown-item-icon">ðŸ–¼ï¸</span>Image</div>
                        </div>
                        <div class="dropdown-section">
                            <div class="dropdown-section-title">Lists</div>
                            <div class="dropdown-item" data-tag="ul"><span class="dropdown-item-icon">â€¢</span>Bullet List</div>
                            <div class="dropdown-item" data-tag="ol"><span class="dropdown-item-icon">1.</span>Numbered List</div>
                            <div class="dropdown-item" data-tag="li"><span class="dropdown-item-icon">â†’</span>List Item</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="toolbar-section">
                <button class="btn" id="btn-undo" disabled title="Undo">
                    <span>Undo</span>
                </button>
                <button class="btn" id="btn-redo" disabled title="Redo">
                    <span>Redo</span>
                </button>
            </div>

            <div class="toolbar-section">
                <div class="viewport-selector" id="viewport-selector">
                    <button class="viewport-btn" data-viewport="phone" title="Phone (375px)">ðŸ“±</button>
                    <button class="viewport-btn" data-viewport="tablet" title="Tablet (768px)">ðŸ“Ÿ</button>
                    <button class="viewport-btn" data-viewport="desktop" title="Desktop (1200px)">ðŸ–¥ï¸</button>
                    <button class="viewport-btn active" data-viewport="fullwidth" title="Full Width">â¬œ</button>
                </div>
                <span class="viewport-size" id="viewport-size">800 Ã— 600</span>
            </div>

            <div class="toolbar-section zoom-controls">
                <button class="btn btn-icon" id="btn-zoom-out" title="Zoom Out (- key)">âˆ’</button>
                <span class="zoom-level" id="zoom-level" title="Reset to 100% (0 key)">100%</span>
                <button class="btn btn-icon" id="btn-zoom-in" title="Zoom In (+ key)">+</button>
                <button class="btn" id="btn-fit" title="Fit to Screen (1 key)">Fit</button>
                <button class="btn btn-icon" id="btn-grid" title="Toggle Grid (G)">âŠž</button>
            </div>

            <div class="toolbar-section">
                <div class="mode-toggle" id="mode-toggle">
                    <button class="mode-toggle-btn active" id="btn-edit-mode" title="Edit Mode (P)">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                        </svg>
                        Edit
                    </button>
                    <button class="mode-toggle-btn" id="btn-preview-mode" title="Preview Mode (P)">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                            <circle cx="12" cy="12" r="3"/>
                        </svg>
                        Preview
                    </button>
                </div>
            </div>

            <div class="toolbar-section" style="margin-left: auto;">
                <button class="btn btn-icon" id="btn-theme" title="Toggle Dark/Light Mode">
                    <span id="theme-icon">â˜€ï¸</span>
                </button>
                <button class="btn btn-primary" id="btn-export" disabled title="Download your file">
                    <span>Download</span>
                </button>
            </div>
        </header>

        <!-- Element Tree -->
        <aside class="sidebar-left">
            <div class="sidebar-header">Page Structure</div>
            <div class="tree-search">
                <div class="tree-search-wrapper" id="tree-search-wrapper">
                    <span class="tree-search-icon">ðŸ”</span>
                    <input type="text" class="tree-search-input" id="tree-search-input" placeholder="Search elements...">
                    <button class="tree-search-clear" id="tree-search-clear">Ã—</button>
                </div>
            </div>
            <div class="search-mode-toggle">
                <button class="search-mode-btn active" id="search-mode-elements" data-mode="elements">Elements</button>
                <button class="search-mode-btn" id="search-mode-text" data-mode="text">Text Content</button>
            </div>
            <div class="tree-search-count" id="tree-search-count"></div>
            <div class="element-tree" id="element-tree">
                <div class="no-selection">Load an HTML file to see elements</div>
            </div>
            <div class="text-search-results" id="text-search-results">
                <div class="text-search-hint" id="text-search-hint">Type to search text content (e.g., find typos)</div>
            </div>
        </aside>

        <!-- Canvas -->
        <main class="canvas-area" id="canvas-area">
            <div class="welcome-screen" id="welcome-screen">
                <div class="welcome-content">
                    <div class="welcome-logo">âœ¦</div>
                    <h1 class="welcome-title">mangle.html</h1>
                    <p class="welcome-subtitle">The visual HTML editor. Load any file, edit with precision, export clean code.</p>

                    <div class="drop-zone" id="drop-zone">
                        <div class="drop-zone-icon">ðŸ“</div>
                        <div class="drop-zone-text">Drop your HTML file here</div>
                        <div class="drop-zone-hint">or click to browse your files</div>
                    </div>

                    <div class="welcome-divider">or start fresh</div>

                    <button class="btn-sample" id="btn-sample">
                        <span>âœ¦</span>
                        <span>Try with sample project</span>
                    </button>

                    <div class="features-grid">
                        <div class="feature-card">
                            <div class="feature-icon">ðŸŽ¯</div>
                            <div class="feature-title">Direct Selection</div>
                            <div class="feature-desc">Click to select, Shift+click for multi-select</div>
                        </div>
                        <div class="feature-card">
                            <div class="feature-icon">ðŸŽ¨</div>
                            <div class="feature-title">Visual Styling</div>
                            <div class="feature-desc">Colors, fonts, spacing - all in real time</div>
                        </div>
                        <div class="feature-card">
                            <div class="feature-icon">ðŸŒ³</div>
                            <div class="feature-title">Page Structure</div>
                            <div class="feature-desc">Drag elements to reorder them</div>
                        </div>
                    </div>

                    <div class="shortcuts-help-link">
                        <a id="show-shortcuts-link">Keyboard shortcuts available</a>
                    </div>
                </div>
            </div>
            <div class="canvas-viewport" id="canvas-viewport">
                <div class="canvas-transform" id="canvas-transform">
                    <div class="device-frame fullwidth" id="device-frame">
                        <div class="canvas-wrapper hidden" id="canvas-wrapper">
                            <iframe id="preview-frame" width="800" height="600"></iframe>
                            <div class="grid-overlay" id="grid-overlay">
                                <svg id="grid-svg"></svg>
                            </div>
                            <div id="guide-container"></div>
                            <!-- Resize Handles Overlay -->
                            <div class="resize-overlay" id="resize-overlay">
                                <div class="resize-box" id="resize-box">
                                    <div class="resize-handle nw" data-handle="nw"></div>
                                    <div class="resize-handle n" data-handle="n"></div>
                                    <div class="resize-handle ne" data-handle="ne"></div>
                                    <div class="resize-handle e" data-handle="e"></div>
                                    <div class="resize-handle se" data-handle="se"></div>
                                    <div class="resize-handle s" data-handle="s"></div>
                                    <div class="resize-handle sw" data-handle="sw"></div>
                                    <div class="resize-handle w" data-handle="w"></div>
                                    <div class="resize-dimensions" id="resize-dimensions"></div>
                                    <div class="constraint-tooltip" id="constraint-tooltip">Size controlled by parent</div>
                                    <div class="position-hint" id="position-hint">Set position to move freely</div>
                                </div>
                            </div>
                            <!-- Spacing Overlay -->
                            <div class="spacing-overlay" id="spacing-overlay">
                                <!-- Margin boxes (orange) -->
                                <div class="spacing-margin spacing-margin-top" id="spacing-margin-top">
                                    <span class="spacing-label margin-label top" id="margin-top-label">0</span>
                                </div>
                                <div class="spacing-margin spacing-margin-right" id="spacing-margin-right">
                                    <span class="spacing-label margin-label right" id="margin-right-label">0</span>
                                </div>
                                <div class="spacing-margin spacing-margin-bottom" id="spacing-margin-bottom">
                                    <span class="spacing-label margin-label bottom" id="margin-bottom-label">0</span>
                                </div>
                                <div class="spacing-margin spacing-margin-left" id="spacing-margin-left">
                                    <span class="spacing-label margin-label left" id="margin-left-label">0</span>
                                </div>
                                <!-- Padding boxes (green) -->
                                <div class="spacing-padding spacing-padding-top" id="spacing-padding-top">
                                    <span class="spacing-label padding-label top" id="padding-top-label">0</span>
                                </div>
                                <div class="spacing-padding spacing-padding-right" id="spacing-padding-right">
                                    <span class="spacing-label padding-label right" id="padding-right-label">0</span>
                                </div>
                                <div class="spacing-padding spacing-padding-bottom" id="spacing-padding-bottom">
                                    <span class="spacing-label padding-label bottom" id="padding-bottom-label">0</span>
                                </div>
                                <div class="spacing-padding spacing-padding-left" id="spacing-padding-left">
                                    <span class="spacing-label padding-label left" id="padding-left-label">0</span>
                                </div>
                                <!-- Content area (blue) -->
                                <div class="spacing-content" id="spacing-content"></div>
                                <!-- Draggable edges -->
                                <div class="spacing-edge horizontal margin-top" data-type="margin" data-side="top"></div>
                                <div class="spacing-edge vertical margin-right" data-type="margin" data-side="right"></div>
                                <div class="spacing-edge horizontal margin-bottom" data-type="margin" data-side="bottom"></div>
                                <div class="spacing-edge vertical margin-left" data-type="margin" data-side="left"></div>
                                <div class="spacing-edge horizontal padding-top" data-type="padding" data-side="top"></div>
                                <div class="spacing-edge vertical padding-right" data-type="padding" data-side="right"></div>
                                <div class="spacing-edge horizontal padding-bottom" data-type="padding" data-side="bottom"></div>
                                <div class="spacing-edge vertical padding-left" data-type="padding" data-side="left"></div>
                                <!-- Presets bar -->
                                <div class="spacing-presets" id="spacing-presets">
                                    <button class="spacing-preset" data-value="0">0</button>
                                    <button class="spacing-preset" data-value="8">8</button>
                                    <button class="spacing-preset" data-value="16">16</button>
                                    <button class="spacing-preset" data-value="24">24</button>
                                    <button class="spacing-preset" data-value="32">32</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Properties Panel -->
        <aside class="sidebar-right" id="properties-panel">
            <div class="no-selection" id="no-selection">
                Select an element to edit its properties
            </div>

            <div id="property-sections" style="display: none;">
                <!-- Content Section -->
                <div class="property-section">
                    <div class="property-section-title">Content</div>
                    <div class="property-row">
                        <label class="property-label">Tag</label>
                        <input type="text" class="property-input" id="prop-tag" readonly>
                    </div>
                    <div class="property-row" id="text-content-row">
                        <label class="property-label">Text <span style="font-weight: 400; color: var(--text-muted); font-size: 11px;">(double-click to edit)</span></label>
                        <textarea class="property-input property-textarea" id="prop-text" placeholder="Element text content"></textarea>
                    </div>
                </div>

                <!-- Typography Section -->
                <div class="property-section">
                    <div class="property-section-title">Text Style</div>
                    <div class="property-row">
                        <label class="property-label">Font Size</label>
                        <select class="property-input property-select" id="prop-font-size">
                            <option value="12px">Small (12px)</option>
                            <option value="14px">Medium (14px)</option>
                            <option value="16px" selected>Normal (16px)</option>
                            <option value="18px">Large (18px)</option>
                            <option value="24px">XL (24px)</option>
                            <option value="32px">XXL (32px)</option>
                            <option value="48px">Huge (48px)</option>
                            <option value="custom">Custom...</option>
                        </select>
                    </div>
                    <div class="property-row">
                        <label class="property-label">Font Family</label>
                        <div class="font-picker-wrapper" id="font-picker-wrapper">
                            <div class="font-picker-trigger" id="font-picker-trigger">
                                <span class="font-picker-preview" id="font-picker-preview">Select font...</span>
                                <span class="font-picker-arrow">â–¼</span>
                            </div>
                            <div class="font-picker-dropdown" id="font-picker-dropdown">
                                <div class="font-picker-search">
                                    <input type="text" class="font-picker-search-input" id="font-picker-search" placeholder="Search fonts...">
                                </div>
                                <div class="font-picker-list" id="font-picker-list">
                                    <!-- Dynamic content -->
                                </div>
                            </div>
                        </div>
                        <div class="font-style-toggles">
                            <button class="font-style-btn font-style-btn-bold" id="font-style-bold" title="Bold">B</button>
                            <button class="font-style-btn font-style-btn-italic" id="font-style-italic" title="Italic">I</button>
                        </div>
                    </div>
                    <div class="property-row">
                        <label class="property-label">Font Weight</label>
                        <select class="property-input" id="prop-font-weight">
                            <option value="">Default</option>
                            <option value="normal">Normal</option>
                            <option value="bold">Bold</option>
                            <option value="100">100</option>
                            <option value="200">200</option>
                            <option value="300">300</option>
                            <option value="400">400</option>
                            <option value="500">500</option>
                            <option value="600">600</option>
                            <option value="700">700</option>
                            <option value="800">800</option>
                            <option value="900">900</option>
                        </select>
                    </div>
                    <div class="property-row">
                        <label class="property-label">Color</label>
                        <div class="color-picker-wrapper">
                            <div class="color-picker-row">
                                <input type="color" class="property-input" id="prop-color" value="#000000">
                                <span class="color-value-display" id="prop-color-value" title="Click to copy">#000000</span>
                            </div>
                            <label class="apply-all-checkbox">
                                <input type="checkbox" id="apply-all-text-color">
                                <span>Apply to all matching colors</span>
                            </label>
                            <div class="document-colors" id="doc-colors-text">
                                <div class="document-colors-header">
                                    <span class="document-colors-label">Document colors</span>
                                </div>
                                <div class="document-colors-grid" id="doc-colors-text-grid"></div>
                                <div class="doc-color-actions">
                                    <button class="btn-replace-color" id="btn-replace-text-color" disabled>Replace all...</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="property-row">
                        <label class="property-label">Text Align</label>
                        <select class="property-input" id="prop-text-align">
                            <option value="">Default</option>
                            <option value="left">Left</option>
                            <option value="center">Center</option>
                            <option value="right">Right</option>
                            <option value="justify">Justify</option>
                        </select>
                    </div>
                </div>

                <!-- Colors Section -->
                <div class="property-section">
                    <div class="property-section-title">Background</div>
                    <div class="property-row">
                        <label class="property-label">Color</label>
                        <div class="color-picker-wrapper">
                            <div class="color-picker-row">
                                <input type="color" class="property-input" id="prop-bg-color" value="#ffffff">
                                <span class="color-value-display" id="prop-bg-color-value" title="Click to copy">#ffffff</span>
                            </div>
                            <label class="apply-all-checkbox">
                                <input type="checkbox" id="apply-all-bg-color">
                                <span>Apply to all matching colors</span>
                            </label>
                            <div class="document-colors" id="doc-colors-bg">
                                <div class="document-colors-header">
                                    <span class="document-colors-label">Document colors</span>
                                </div>
                                <div class="document-colors-grid" id="doc-colors-bg-grid"></div>
                                <div class="doc-color-actions">
                                    <button class="btn-replace-color" id="btn-replace-bg-color" disabled>Replace all...</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Spacing Section -->
                <div class="property-section">
                    <div class="property-section-title">Margin</div>
                    <div class="spacing-grid">
                        <div></div>
                        <input type="text" class="property-input" id="prop-margin-top" placeholder="0">
                        <div></div>
                        <input type="text" class="property-input" id="prop-margin-left" placeholder="0">
                        <div class="center">M</div>
                        <input type="text" class="property-input" id="prop-margin-right" placeholder="0">
                        <div></div>
                        <input type="text" class="property-input" id="prop-margin-bottom" placeholder="0">
                        <div></div>
                    </div>
                </div>

                <div class="property-section">
                    <div class="property-section-title">Padding</div>
                    <div class="spacing-grid">
                        <div></div>
                        <input type="text" class="property-input" id="prop-padding-top" placeholder="0">
                        <div></div>
                        <input type="text" class="property-input" id="prop-padding-left" placeholder="0">
                        <div class="center">P</div>
                        <input type="text" class="property-input" id="prop-padding-right" placeholder="0">
                        <div></div>
                        <input type="text" class="property-input" id="prop-padding-bottom" placeholder="0">
                        <div></div>
                    </div>
                </div>

                <!-- Size Section -->
                <div class="property-section">
                    <div class="property-section-title">Size</div>
                    <div class="property-row">
                        <label class="property-label">Width</label>
                        <input type="text" class="property-input" id="prop-width" placeholder="auto">
                    </div>
                    <div class="property-row">
                        <label class="property-label">Height</label>
                        <input type="text" class="property-input" id="prop-height" placeholder="auto">
                    </div>
                </div>
            </div>
        </aside>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toast-container"></div>

    <!-- Color Replace Modal -->
    <div class="color-replace-modal" id="color-replace-modal">
        <div class="color-replace-modal-content">
            <div class="color-replace-title">Replace Color</div>
            <div class="color-replace-preview">
                <div class="color-replace-swatch" id="replace-from-swatch">
                    <span class="color-replace-swatch-label">From</span>
                </div>
                <span class="color-replace-arrow">â†’</span>
                <div class="color-replace-swatch" id="replace-to-swatch">
                    <span class="color-replace-swatch-label">To</span>
                </div>
            </div>
            <div class="color-replace-info" id="replace-info">
                Found <strong id="replace-count">0</strong> elements using this color
            </div>
            <div class="color-replace-new-color">
                <label>New color:</label>
                <input type="color" id="replace-new-color" value="#000000">
                <span class="color-value-display" id="replace-new-color-value">#000000</span>
            </div>
            <div class="color-replace-actions">
                <button class="btn" id="btn-cancel-replace">Cancel</button>
                <button class="btn btn-primary" id="btn-confirm-replace">Replace All</button>
            </div>
        </div>
    </div>

    <!-- Spacing Drag Value Display -->
    <div class="spacing-drag-value" id="spacing-drag-value">0px</div>

    <!-- Shortcuts Modal -->
    <div class="shortcuts-modal-overlay" id="shortcuts-modal">
        <div class="shortcuts-modal">
            <div class="shortcuts-modal-header">
                <div class="shortcuts-modal-title">Keyboard Shortcuts</div>
                <button class="shortcuts-modal-close" id="shortcuts-modal-close">&times;</button>
            </div>
            <div class="shortcuts-list">
                <div class="shortcut-row">
                    <span class="shortcut-action">Undo</span>
                    <span class="shortcut-keys"><kbd>Ctrl</kbd><kbd>Z</kbd></span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-action">Redo</span>
                    <span class="shortcut-keys"><kbd>Ctrl</kbd><kbd>Y</kbd></span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-action">Delete element</span>
                    <span class="shortcut-keys"><kbd>Del</kbd></span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-action">Duplicate element</span>
                    <span class="shortcut-keys"><kbd>Ctrl</kbd><kbd>D</kbd></span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-action">Copy element</span>
                    <span class="shortcut-keys"><kbd>Ctrl</kbd><kbd>C</kbd></span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-action">Paste element</span>
                    <span class="shortcut-keys"><kbd>Ctrl</kbd><kbd>V</kbd></span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-action">Nudge element</span>
                    <span class="shortcut-keys"><kbd>â†‘</kbd><kbd>â†“</kbd><kbd>â†</kbd><kbd>â†’</kbd></span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-action">Pan canvas</span>
                    <span class="shortcut-keys"><kbd>Space</kbd> + drag</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-action">Zoom</span>
                    <span class="shortcut-keys"><kbd>Ctrl</kbd> + scroll</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-action">Fit to screen</span>
                    <span class="shortcut-keys"><kbd>Ctrl</kbd><kbd>0</kbd></span>
                </div>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <!-- Quick Actions Toolbar -->
    <div class="quick-actions" id="quick-actions">
        <!-- Common actions -->
        <div class="qa-group" id="qa-common">
            <button class="qa-btn" data-action="center-h" data-tooltip="Center horizontally">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="2" x2="12" y2="22"/>
                    <polyline points="8 6 12 2 16 6"/>
                    <polyline points="8 18 12 22 16 18"/>
                </svg>
            </button>
            <button class="qa-btn" data-action="center-v" data-tooltip="Center vertically">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="2" y1="12" x2="22" y2="12"/>
                    <polyline points="6 8 2 12 6 16"/>
                    <polyline points="18 8 22 12 18 16"/>
                </svg>
            </button>
            <button class="qa-btn" data-action="full-width" data-tooltip="Full width">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="8 4 4 4 4 20 8 20"/>
                    <polyline points="16 4 20 4 20 20 16 20"/>
                    <line x1="4" y1="12" x2="20" y2="12"/>
                </svg>
            </button>
            <button class="qa-btn" data-action="auto-size" data-tooltip="Reset to auto">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 21l-6-6m6 6v-4.8m0 4.8h-4.8"/>
                    <path d="M3 16.2V21m0 0h4.8M3 21l6-6"/>
                    <path d="M21 7.8V3m0 0h-4.8M21 3l-6 6"/>
                    <path d="M3 7.8V3m0 0h4.8M3 3l6 6"/>
                </svg>
            </button>
        </div>

        <div class="quick-actions-divider"></div>

        <!-- Transform actions -->
        <div class="qa-group" id="qa-transform">
            <button class="qa-btn" data-action="flip-h" data-tooltip="Flip horizontal">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 3v18"/>
                    <path d="M16 7l4 5-4 5"/>
                    <path d="M8 7l-4 5 4 5"/>
                </svg>
            </button>
            <button class="qa-btn" data-action="flip-v" data-tooltip="Flip vertical">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 12h18"/>
                    <path d="M7 16l5 4 5-4"/>
                    <path d="M7 8l5-4 5 4"/>
                </svg>
            </button>
        </div>

        <div class="quick-actions-divider"></div>

        <!-- Z-index actions -->
        <div class="qa-group" id="qa-zindex">
            <button class="qa-btn" data-action="bring-front" data-tooltip="Bring to front">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="8" y="8" width="12" height="12" rx="2"/>
                    <path d="M4 16V6a2 2 0 012-2h10"/>
                </svg>
            </button>
            <button class="qa-btn" data-action="send-back" data-tooltip="Send to back">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="4" y="4" width="12" height="12" rx="2"/>
                    <path d="M20 8v10a2 2 0 01-2 2H8"/>
                </svg>
            </button>
        </div>

        <div class="quick-actions-divider"></div>

        <!-- Structure actions -->
        <div class="qa-group" id="qa-structure">
            <button class="qa-btn" data-action="wrap-div" data-tooltip="Wrap in div">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                    <rect x="7" y="7" width="10" height="10" rx="1"/>
                </svg>
            </button>
            <button class="qa-btn" data-action="unwrap" data-tooltip="Unwrap">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="7" y="7" width="10" height="10" rx="1"/>
                    <path d="M3 7V5a2 2 0 012-2h2"/>
                    <path d="M17 3h2a2 2 0 012 2v2"/>
                    <path d="M21 17v2a2 2 0 01-2 2h-2"/>
                    <path d="M7 21H5a2 2 0 01-2-2v-2"/>
                </svg>
            </button>
        </div>

        <div class="quick-actions-divider"></div>

        <!-- Layout conversion -->
        <div class="qa-group" id="qa-layout">
            <div class="qa-dropdown" id="qa-layout-dropdown">
                <button class="qa-btn" data-action="toggle-layout-menu" data-tooltip="Convert layout">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="7" height="7"/>
                        <rect x="14" y="3" width="7" height="7"/>
                        <rect x="3" y="14" width="7" height="7"/>
                        <rect x="14" y="14" width="7" height="7"/>
                    </svg>
                </button>
                <div class="qa-dropdown-menu">
                    <div class="qa-dropdown-item" data-action="make-flex">
                        <span class="qa-dropdown-item-icon">â¬Œ</span>
                        <span>Make Flex Row</span>
                    </div>
                    <div class="qa-dropdown-item" data-action="make-flex-col">
                        <span class="qa-dropdown-item-icon">â¬</span>
                        <span>Make Flex Column</span>
                    </div>
                    <div class="qa-dropdown-item" data-action="make-grid">
                        <span class="qa-dropdown-item-icon">âŠž</span>
                        <span>Make Grid</span>
                    </div>
                    <div class="qa-dropdown-item" data-action="make-block">
                        <span class="qa-dropdown-item-icon">â–¢</span>
                        <span>Make Block</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Image-specific actions -->
        <div class="qa-group hidden" id="qa-image">
            <div class="quick-actions-divider"></div>
            <button class="qa-btn" data-action="img-contain" data-tooltip="Object fit: contain">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                    <rect x="6" y="8" width="12" height="8"/>
                </svg>
            </button>
            <button class="qa-btn" data-action="img-cover" data-tooltip="Object fit: cover">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                    <rect x="1" y="6" width="22" height="12"/>
                </svg>
            </button>
            <button class="qa-btn" data-action="img-fill" data-tooltip="Object fit: fill">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2" fill="currentColor" fill-opacity="0.2"/>
                </svg>
            </button>
        </div>

        <!-- Text-specific actions -->
        <div class="qa-group hidden" id="qa-text">
            <div class="quick-actions-divider"></div>
            <button class="qa-btn" data-action="text-left" data-tooltip="Align left">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="6" x2="21" y2="6"/>
                    <line x1="3" y1="12" x2="15" y2="12"/>
                    <line x1="3" y1="18" x2="18" y2="18"/>
                </svg>
            </button>
            <button class="qa-btn" data-action="text-center" data-tooltip="Align center">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="6" x2="21" y2="6"/>
                    <line x1="6" y1="12" x2="18" y2="12"/>
                    <line x1="4" y1="18" x2="20" y2="18"/>
                </svg>
            </button>
            <button class="qa-btn" data-action="text-right" data-tooltip="Align right">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="6" x2="21" y2="6"/>
                    <line x1="9" y1="12" x2="21" y2="12"/>
                    <line x1="6" y1="18" x2="21" y2="18"/>
                </svg>
            </button>
            <button class="qa-btn" data-action="text-bold" data-tooltip="Toggle bold">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"/>
                    <path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"/>
                </svg>
            </button>
        </div>
    </div>

    <!-- Style Clipboard Indicator -->
    <div class="style-clipboard-indicator" id="style-clipboard-indicator">
        <div class="style-clipboard-icon">ðŸŽ¨</div>
        <div>
            <div class="style-clipboard-text">Style copied</div>
            <div class="style-clipboard-hint">Click an element to apply this style</div>
        </div>
        <button class="style-clipboard-clear" id="style-clipboard-clear" title="Clear style clipboard">âœ•</button>
    </div>

    <!-- Style Preview Overlay -->
    <div class="style-preview-overlay" id="style-preview-overlay">
        <div class="style-preview-title">Style Preview</div>
        <div id="style-preview-content"></div>
    </div>

    <div class="context-menu" id="context-menu">
        <div class="context-menu-item" id="ctx-undo" data-action="undo">
            <span class="context-menu-item-icon">â†©ï¸</span>
            <span class="context-menu-item-label">Undo</span>
            <span class="context-menu-item-shortcut">Ctrl+Z</span>
        </div>
        <div class="context-menu-item" id="ctx-redo" data-action="redo">
            <span class="context-menu-item-icon">â†ªï¸</span>
            <span class="context-menu-item-label">Redo</span>
            <span class="context-menu-item-shortcut">Ctrl+Y</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="edit-text">
            <span class="context-menu-item-icon">âœï¸</span>
            <span class="context-menu-item-label">Edit Text</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="duplicate">
            <span class="context-menu-item-icon">ðŸ“‹</span>
            <span class="context-menu-item-label">Duplicate</span>
            <span class="context-menu-item-shortcut">Ctrl+D</span>
        </div>
        <div class="context-menu-item" data-action="duplicate-section" id="ctx-duplicate-section" style="display: none;">
            <span class="context-menu-item-icon">ðŸ“‘</span>
            <span class="context-menu-item-label">Duplicate This Section</span>
        </div>
        <div class="context-menu-item" data-action="copy">
            <span class="context-menu-item-icon">ðŸ“„</span>
            <span class="context-menu-item-label">Copy</span>
            <span class="context-menu-item-shortcut">Ctrl+C</span>
        </div>
        <div class="context-menu-item" data-action="paste">
            <span class="context-menu-item-icon">ðŸ“¥</span>
            <span class="context-menu-item-label">Paste</span>
            <span class="context-menu-item-shortcut">Ctrl+V</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="copy-style">
            <span class="context-menu-item-icon">ðŸŽ¨</span>
            <span class="context-menu-item-label">Copy Style</span>
            <span class="context-menu-item-shortcut">â‡§âŒ˜C</span>
        </div>
        <div class="context-menu-item" data-action="paste-style">
            <span class="context-menu-item-icon">ðŸ–Œï¸</span>
            <span class="context-menu-item-label">Paste Style</span>
            <span class="context-menu-item-shortcut">â‡§âŒ˜V</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="move-up">
            <span class="context-menu-item-icon">â¬†ï¸</span>
            <span class="context-menu-item-label">Move Up</span>
        </div>
        <div class="context-menu-item" data-action="move-down">
            <span class="context-menu-item-icon">â¬‡ï¸</span>
            <span class="context-menu-item-label">Move Down</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="delete">
            <span class="context-menu-item-icon">ðŸ—‘ï¸</span>
            <span class="context-menu-item-label">Delete</span>
            <span class="context-menu-item-shortcut">Del</span>
        </div>
    </div>

    <script>
    (function() {
        'use strict';

        // =========================================================================
        // State Management
        // =========================================================================

        const state = {
            originalHtml: '',
            currentHtml: '',
            selectedElement: null,
            selectedPath: null,
            // Multi-select support
            selectedElements: [],
            selectedPaths: [],
            // Clipboard for copy/paste
            clipboard: [],
            // Style clipboard for copy/paste styles
            styleClipboard: null,
            eyedropperMode: false,
            fileName: 'document.html',
            undoStack: [],
            redoStack: [],
            maxUndoSteps: 50,
            draggedPath: null,
            // Alt+drag cloning state
            isAltDrag: false,
            // Zoom & Pan state
            zoom: 1,
            panX: 0,
            panY: 0,
            isPanning: false,
            isSpaceDown: false,
            lastMouseX: 0,
            lastMouseY: 0,
            minZoom: 0.1,
            maxZoom: 5,
            zoomStep: 0.1,
            // Document loaded
            documentLoaded: false,
            // Performance optimization state
            treeData: [],
            treeScrollTop: 0,
            visibleTreeStart: 0,
            visibleTreeEnd: 0,
            treeItemHeight: 25,
            treeBuffer: 10,
            // Grid and guides state
            gridVisible: false,
            gridSize: 20,
            snapThreshold: 8,
            guides: [],
            // Preview/Edit mode
            previewMode: false,
            // Responsive viewport state
            currentViewport: 'fullwidth',
            viewportSizes: {
                phone: { width: 375, height: 667 },
                tablet: { width: 768, height: 1024 },
                desktop: { width: 1200, height: 800 },
                fullwidth: { width: 800, height: 600 }
            },
            // Resize/Move state
            isResizing: false,
            isMoving: false,
            resizeHandle: null,
            resizeStartX: 0,
            resizeStartY: 0,
            resizeStartWidth: 0,
            resizeStartHeight: 0,
            resizeStartLeft: 0,
            resizeStartTop: 0,
            resizeAspectRatio: 1,
            resizeShiftKey: false,
            elementConstraints: null,
            // Spacing drag state
            isSpacingDrag: false,
            spacingDragType: null, // 'margin' or 'padding'
            spacingDragSide: null, // 'top', 'right', 'bottom', 'left'
            spacingDragStartY: 0,
            spacingDragStartX: 0,
            spacingDragStartValue: 0,
            spacingShiftKey: false,
            // Search mode state
            searchMode: 'elements', // 'elements' or 'text'
            textSearchResults: [],
            // Document colors state
            documentColors: [],
            documentFonts: [],
            recentFonts: JSON.parse(localStorage.getItem('mangle-recent-fonts') || '[]'),
            fontPickerOpen: false,
            selectedDocColor: null,
            replaceColorType: null, // 'text' or 'bg'
            replaceFromColor: null,
            // Track last selected colors for "apply to all matching" feature
            lastTextColor: null,
            lastBgColor: null
        };

        // =========================================================================
        // DOM References
        // =========================================================================

        const elements = {
            fileInput: document.getElementById('file-input'),
            btnOpen: document.getElementById('btn-open'),
            btnInsert: document.getElementById('btn-insert'),
            insertDropdown: document.getElementById('insert-dropdown'),
            insertMenu: document.getElementById('insert-menu'),
            btnUndo: document.getElementById('btn-undo'),
            btnRedo: document.getElementById('btn-redo'),
            btnExport: document.getElementById('btn-export'),
            btnTheme: document.getElementById('btn-theme'),
            themeIcon: document.getElementById('theme-icon'),
            btnZoomIn: document.getElementById('btn-zoom-in'),
            btnZoomOut: document.getElementById('btn-zoom-out'),
            btnFit: document.getElementById('btn-fit'),
            zoomLevel: document.getElementById('zoom-level'),
            welcomeScreen: document.getElementById('welcome-screen'),
            dropZone: document.getElementById('drop-zone'),
            btnSample: document.getElementById('btn-sample'),
            canvasArea: document.getElementById('canvas-area'),
            canvasViewport: document.getElementById('canvas-viewport'),
            canvasTransform: document.getElementById('canvas-transform'),
            canvasWrapper: document.getElementById('canvas-wrapper'),
            previewFrame: document.getElementById('preview-frame'),
            gridOverlay: document.getElementById('grid-overlay'),
            gridSvg: document.getElementById('grid-svg'),
            guideContainer: document.getElementById('guide-container'),
            btnGrid: document.getElementById('btn-grid'),
            modeToggle: document.getElementById('mode-toggle'),
            btnEditMode: document.getElementById('btn-edit-mode'),
            btnPreviewMode: document.getElementById('btn-preview-mode'),
            deviceFrame: document.getElementById('device-frame'),
            viewportSelector: document.getElementById('viewport-selector'),
            viewportSize: document.getElementById('viewport-size'),
            elementTree: document.getElementById('element-tree'),
            treeSearchInput: document.getElementById('tree-search-input'),
            treeSearchWrapper: document.getElementById('tree-search-wrapper'),
            treeSearchClear: document.getElementById('tree-search-clear'),
            treeSearchCount: document.getElementById('tree-search-count'),
            searchModeElements: document.getElementById('search-mode-elements'),
            searchModeText: document.getElementById('search-mode-text'),
            textSearchResults: document.getElementById('text-search-results'),
            textSearchHint: document.getElementById('text-search-hint'),
            propertiesPanel: document.getElementById('properties-panel'),
            noSelection: document.getElementById('no-selection'),
            propertySections: document.getElementById('property-sections'),
            propTag: document.getElementById('prop-tag'),
            propText: document.getElementById('prop-text'),
            propFontSize: document.getElementById('prop-font-size'),
            fontPickerWrapper: document.getElementById('font-picker-wrapper'),
            fontPickerTrigger: document.getElementById('font-picker-trigger'),
            fontPickerPreview: document.getElementById('font-picker-preview'),
            fontPickerDropdown: document.getElementById('font-picker-dropdown'),
            fontPickerSearch: document.getElementById('font-picker-search'),
            fontPickerList: document.getElementById('font-picker-list'),
            fontStyleBold: document.getElementById('font-style-bold'),
            fontStyleItalic: document.getElementById('font-style-italic'),
            propFontWeight: document.getElementById('prop-font-weight'),
            propColor: document.getElementById('prop-color'),
            propTextAlign: document.getElementById('prop-text-align'),
            propBgColor: document.getElementById('prop-bg-color'),
            propMarginTop: document.getElementById('prop-margin-top'),
            propMarginRight: document.getElementById('prop-margin-right'),
            propMarginBottom: document.getElementById('prop-margin-bottom'),
            propMarginLeft: document.getElementById('prop-margin-left'),
            propPaddingTop: document.getElementById('prop-padding-top'),
            propPaddingRight: document.getElementById('prop-padding-right'),
            propPaddingBottom: document.getElementById('prop-padding-bottom'),
            propPaddingLeft: document.getElementById('prop-padding-left'),
            propWidth: document.getElementById('prop-width'),
            propHeight: document.getElementById('prop-height'),
            textContentRow: document.getElementById('text-content-row'),
            toastContainer: document.getElementById('toast-container'),
            contextMenu: document.getElementById('context-menu'),
            styleClipboardIndicator: document.getElementById('style-clipboard-indicator'),
            styleClipboardClear: document.getElementById('style-clipboard-clear'),
            stylePreviewOverlay: document.getElementById('style-preview-overlay'),
            stylePreviewContent: document.getElementById('style-preview-content'),
            quickActions: document.getElementById('quick-actions'),
            qaCommon: document.getElementById('qa-common'),
            qaTransform: document.getElementById('qa-transform'),
            qaZindex: document.getElementById('qa-zindex'),
            qaStructure: document.getElementById('qa-structure'),
            qaLayout: document.getElementById('qa-layout'),
            qaLayoutDropdown: document.getElementById('qa-layout-dropdown'),
            qaImage: document.getElementById('qa-image'),
            qaText: document.getElementById('qa-text'),
            // Resize overlay elements
            resizeOverlay: document.getElementById('resize-overlay'),
            resizeBox: document.getElementById('resize-box'),
            resizeDimensions: document.getElementById('resize-dimensions'),
            constraintTooltip: document.getElementById('constraint-tooltip'),
            positionHint: document.getElementById('position-hint'),
            // Spacing overlay elements
            spacingOverlay: document.getElementById('spacing-overlay'),
            spacingMarginTop: document.getElementById('spacing-margin-top'),
            spacingMarginRight: document.getElementById('spacing-margin-right'),
            spacingMarginBottom: document.getElementById('spacing-margin-bottom'),
            spacingMarginLeft: document.getElementById('spacing-margin-left'),
            spacingPaddingTop: document.getElementById('spacing-padding-top'),
            spacingPaddingRight: document.getElementById('spacing-padding-right'),
            spacingPaddingBottom: document.getElementById('spacing-padding-bottom'),
            spacingPaddingLeft: document.getElementById('spacing-padding-left'),
            spacingContent: document.getElementById('spacing-content'),
            spacingPresets: document.getElementById('spacing-presets'),
            spacingDragValue: document.getElementById('spacing-drag-value'),
            marginTopLabel: document.getElementById('margin-top-label'),
            marginRightLabel: document.getElementById('margin-right-label'),
            marginBottomLabel: document.getElementById('margin-bottom-label'),
            marginLeftLabel: document.getElementById('margin-left-label'),
            paddingTopLabel: document.getElementById('padding-top-label'),
            paddingRightLabel: document.getElementById('padding-right-label'),
            paddingBottomLabel: document.getElementById('padding-bottom-label'),
            paddingLeftLabel: document.getElementById('padding-left-label'),
            // Document colors elements
            propColorValue: document.getElementById('prop-color-value'),
            propBgColorValue: document.getElementById('prop-bg-color-value'),
            applyAllTextColor: document.getElementById('apply-all-text-color'),
            applyAllBgColor: document.getElementById('apply-all-bg-color'),
            docColorsTextGrid: document.getElementById('doc-colors-text-grid'),
            docColorsBgGrid: document.getElementById('doc-colors-bg-grid'),
            btnReplaceTextColor: document.getElementById('btn-replace-text-color'),
            btnReplaceBgColor: document.getElementById('btn-replace-bg-color'),
            colorReplaceModal: document.getElementById('color-replace-modal'),
            replaceFromSwatch: document.getElementById('replace-from-swatch'),
            replaceToSwatch: document.getElementById('replace-to-swatch'),
            replaceInfo: document.getElementById('replace-info'),
            replaceCount: document.getElementById('replace-count'),
            replaceNewColor: document.getElementById('replace-new-color'),
            replaceNewColorValue: document.getElementById('replace-new-color-value'),
            btnCancelReplace: document.getElementById('btn-cancel-replace'),
            btnConfirmReplace: document.getElementById('btn-confirm-replace'),
            // Shortcuts modal
            shortcutsModal: document.getElementById('shortcuts-modal'),
            shortcutsModalClose: document.getElementById('shortcuts-modal-close'),
            showShortcutsLink: document.getElementById('show-shortcuts-link')
        };

        // =========================================================================
        // Performance Utilities
        // =========================================================================

        function debounce(fn, delay) {
            let timeoutId;
            return function(...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => fn.apply(this, args), delay);
            };
        }

        function throttle(fn, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    fn.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }

        // Batch DOM operations using requestAnimationFrame
        let pendingTreeRender = null;
        function scheduleTreeRender(root) {
            if (pendingTreeRender) return;
            pendingTreeRender = requestAnimationFrame(() => {
                pendingTreeRender = null;
                buildElementTreeOptimized(root);
            });
        }

        // =========================================================================
        // Theme Management
        // =========================================================================

        function initTheme() {
            const savedTheme = localStorage.getItem('html-editor-theme') || 'dark';
            setTheme(savedTheme);
        }

        function setTheme(theme) {
            if (theme === 'light') {
                document.documentElement.setAttribute('data-theme', 'light');
                elements.themeIcon.textContent = 'ðŸŒ™';
            } else {
                document.documentElement.removeAttribute('data-theme');
                elements.themeIcon.textContent = 'â˜€ï¸';
            }
            localStorage.setItem('html-editor-theme', theme);
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            setTheme(currentTheme === 'light' ? 'dark' : 'light');
        }

        // =========================================================================
        // Grid and Alignment Guides
        // =========================================================================

        function toggleGrid() {
            state.gridVisible = !state.gridVisible;
            elements.gridOverlay.classList.toggle('visible', state.gridVisible);
            elements.btnGrid.classList.toggle('grid-active', state.gridVisible);

            if (state.gridVisible) {
                renderGrid();
            }
        }

        function renderGrid() {
            const width = parseInt(elements.previewFrame.width) || 800;
            const height = parseInt(elements.previewFrame.height) || 600;
            const size = state.gridSize;

            let pathD = '';

            // Vertical lines
            for (let x = size; x < width; x += size) {
                pathD += `M ${x} 0 V ${height} `;
            }

            // Horizontal lines
            for (let y = size; y < height; y += size) {
                pathD += `M 0 ${y} H ${width} `;
            }

            elements.gridSvg.innerHTML = `
                <defs>
                    <pattern id="grid-pattern" width="${size}" height="${size}" patternUnits="userSpaceOnUse">
                        <path d="M ${size} 0 L 0 0 0 ${size}" fill="none" stroke="rgba(128, 128, 128, 0.3)" stroke-width="0.5"/>
                    </pattern>
                </defs>
                <rect width="100%" height="100%" fill="url(#grid-pattern)"/>
            `;
        }

        function showAlignmentGuides(element) {
            if (!element || !state.documentLoaded) return;

            clearGuides();

            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;
            const frameRect = frame.getBoundingClientRect();

            const elemRect = element.getBoundingClientRect();
            const elemCenter = {
                x: elemRect.left + elemRect.width / 2 - frameRect.left,
                y: elemRect.top + elemRect.height / 2 - frameRect.top
            };
            const elemEdges = {
                left: elemRect.left - frameRect.left,
                right: elemRect.right - frameRect.left,
                top: elemRect.top - frameRect.top,
                bottom: elemRect.bottom - frameRect.top
            };

            const threshold = state.snapThreshold / state.zoom;
            const guides = [];

            // Check alignment with other elements
            const allElements = doc.body.querySelectorAll('*:not(script):not(style)');

            allElements.forEach(other => {
                if (other === element || other.contains(element) || element.contains(other)) return;
                if (other.classList.contains('editor-selected') || other.classList.contains('editor-hover')) return;

                const otherRect = other.getBoundingClientRect();
                if (otherRect.width === 0 || otherRect.height === 0) return;

                const otherCenter = {
                    x: otherRect.left + otherRect.width / 2 - frameRect.left,
                    y: otherRect.top + otherRect.height / 2 - frameRect.top
                };
                const otherEdges = {
                    left: otherRect.left - frameRect.left,
                    right: otherRect.right - frameRect.left,
                    top: otherRect.top - frameRect.top,
                    bottom: otherRect.bottom - frameRect.top
                };

                // Horizontal alignment (vertical guide lines)
                // Left edge alignment
                if (Math.abs(elemEdges.left - otherEdges.left) < threshold) {
                    guides.push({ type: 'vertical', pos: otherEdges.left, isCenter: false });
                }
                // Right edge alignment
                if (Math.abs(elemEdges.right - otherEdges.right) < threshold) {
                    guides.push({ type: 'vertical', pos: otherEdges.right, isCenter: false });
                }
                // Left to right alignment
                if (Math.abs(elemEdges.left - otherEdges.right) < threshold) {
                    guides.push({ type: 'vertical', pos: otherEdges.right, isCenter: false });
                }
                // Right to left alignment
                if (Math.abs(elemEdges.right - otherEdges.left) < threshold) {
                    guides.push({ type: 'vertical', pos: otherEdges.left, isCenter: false });
                }
                // Center X alignment
                if (Math.abs(elemCenter.x - otherCenter.x) < threshold) {
                    guides.push({ type: 'vertical', pos: otherCenter.x, isCenter: true });
                }

                // Vertical alignment (horizontal guide lines)
                // Top edge alignment
                if (Math.abs(elemEdges.top - otherEdges.top) < threshold) {
                    guides.push({ type: 'horizontal', pos: otherEdges.top, isCenter: false });
                }
                // Bottom edge alignment
                if (Math.abs(elemEdges.bottom - otherEdges.bottom) < threshold) {
                    guides.push({ type: 'horizontal', pos: otherEdges.bottom, isCenter: false });
                }
                // Top to bottom alignment
                if (Math.abs(elemEdges.top - otherEdges.bottom) < threshold) {
                    guides.push({ type: 'horizontal', pos: otherEdges.bottom, isCenter: false });
                }
                // Bottom to top alignment
                if (Math.abs(elemEdges.bottom - otherEdges.top) < threshold) {
                    guides.push({ type: 'horizontal', pos: otherEdges.top, isCenter: false });
                }
                // Center Y alignment
                if (Math.abs(elemCenter.y - otherCenter.y) < threshold) {
                    guides.push({ type: 'horizontal', pos: otherCenter.y, isCenter: true });
                }
            });

            // Deduplicate guides
            const uniqueGuides = [];
            guides.forEach(g => {
                if (!uniqueGuides.some(u => u.type === g.type && Math.abs(u.pos - g.pos) < 1)) {
                    uniqueGuides.push(g);
                }
            });

            // Render guides
            uniqueGuides.forEach(g => {
                const line = document.createElement('div');
                line.className = `guide-line ${g.type}${g.isCenter ? ' center' : ''}`;

                if (g.type === 'horizontal') {
                    line.style.top = g.pos + 'px';
                } else {
                    line.style.left = g.pos + 'px';
                }

                elements.guideContainer.appendChild(line);
            });

            state.guides = uniqueGuides;
        }

        function clearGuides() {
            elements.guideContainer.innerHTML = '';
            state.guides = [];
        }

        // =========================================================================
        // Responsive Viewport
        // =========================================================================

        function setViewport(viewport) {
            const size = state.viewportSizes[viewport];
            if (!size) return;

            state.currentViewport = viewport;

            // Update iframe size
            elements.previewFrame.width = size.width;
            elements.previewFrame.height = size.height;

            // Update device frame class
            elements.deviceFrame.className = 'device-frame ' + viewport;

            // Update viewport buttons
            elements.viewportSelector.querySelectorAll('.viewport-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.viewport === viewport);
            });

            // Update size display
            elements.viewportSize.textContent = size.width + ' Ã— ' + size.height;

            // Re-render grid if visible
            if (state.gridVisible) {
                renderGrid();
            }

            // Center the canvas
            requestAnimationFrame(() => {
                centerCanvas();
            });
        }

        function initViewportSelector() {
            elements.viewportSelector.addEventListener('click', (e) => {
                const btn = e.target.closest('.viewport-btn');
                if (btn && btn.dataset.viewport) {
                    setViewport(btn.dataset.viewport);
                }
            });
        }


        // =========================================================================
        // Preview/Edit Mode
        // =========================================================================

        function setPreviewMode(enabled) {
            state.previewMode = enabled;

            // Update toggle buttons
            elements.btnEditMode.classList.toggle('active', !enabled);
            elements.btnPreviewMode.classList.toggle('active', enabled);

            // Toggle app-level preview mode class (hides sidebars)
            document.querySelector('.app').classList.toggle('preview-mode', enabled);

            // Update canvas wrapper
            elements.canvasWrapper.classList.toggle('preview-mode', enabled);

            if (enabled) {
                // PREVIEW MODE: Clean view, no editing UI

                // Deselect everything
                if (state.selectedElement) {
                    clearSelection();
                }

                // Hide all editing overlays
                hideQuickActions();
                clearGuides();
                if (elements.resizeOverlay) {
                    elements.resizeOverlay.classList.remove('active');
                }
                if (elements.spacingOverlay) {
                    elements.spacingOverlay.classList.remove('active');
                }
                if (elements.gridOverlay) {
                    elements.gridOverlay.classList.remove('visible');
                }

                // Remove any selection highlighting from iframe
                const frame = elements.previewFrame;
                if (frame.contentDocument) {
                    const highlighted = frame.contentDocument.querySelectorAll('[data-mangle-selected]');
                    highlighted.forEach(el => {
                        el.removeAttribute('data-mangle-selected');
                        el.style.outline = '';
                    });
                }
            } else {
                // EDIT MODE: Show editing tools
                if (state.selectedElement) {
                    updateQuickActions();
                }
            }

            // Update iframe interactions
            const frame = elements.previewFrame;
            if (frame.contentDocument) {
                frame.contentDocument.body.style.pointerEvents = enabled ? 'auto' : 'none';
            }

            // Show toast notification (brief)
            if (enabled) {
                showToast('info', 'Preview Mode', 'Clean view. Press P to edit.', 2000);
            } else {
                showToast('info', 'Edit Mode', 'Click elements to select.', 2000);
            }
        }

        function togglePreviewMode() {
            setPreviewMode(!state.previewMode);
        }

        function initModeToggle() {
            elements.btnEditMode.addEventListener('click', () => setPreviewMode(false));
            elements.btnPreviewMode.addEventListener('click', () => setPreviewMode(true));
        }

        // =========================================================================
        // Toast Notifications
        // =========================================================================

        function showToast(type, title, message, duration = 5000) {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;

            const icons = { error: 'âŒ', warning: 'âš ï¸', info: 'â„¹ï¸', success: 'âœ“' };

            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || 'â„¹ï¸'}</span>
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    <div class="toast-message">${message}</div>
                </div>
                <button class="toast-close">Ã—</button>
            `;

            const closeBtn = toast.querySelector('.toast-close');
            closeBtn.addEventListener('click', () => dismissToast(toast));

            elements.toastContainer.appendChild(toast);

            if (duration > 0) {
                setTimeout(() => dismissToast(toast), duration);
            }

            return toast;
        }

        function dismissToast(toast) {
            if (!toast.parentElement) return;
            toast.classList.add('toast-out');
            setTimeout(() => toast.remove(), 300);
        }

        // =========================================================================
        // Quick Actions Toolbar
        // =========================================================================

        function updateQuickActions() {
            if (!state.selectedElement || state.previewMode || state.selectedElements.length > 1) {
                hideQuickActions();
                return;
            }

            const element = state.selectedElement;
            const tag = element.tagName.toUpperCase();

            // Show/hide element-specific action groups
            const isImage = tag === 'IMG';
            const isText = ['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'SPAN', 'A', 'BUTTON', 'LI', 'LABEL'].includes(tag);
            const isContainer = ['DIV', 'SECTION', 'ARTICLE', 'NAV', 'HEADER', 'FOOTER', 'MAIN', 'ASIDE', 'UL', 'OL'].includes(tag);

            elements.qaImage.classList.toggle('hidden', !isImage);
            elements.qaText.classList.toggle('hidden', !isText);

            // Position the toolbar
            positionQuickActions();

            // Show toolbar
            elements.quickActions.classList.add('visible');
        }

        function positionQuickActions() {
            if (!state.selectedElement) return;

            const element = state.selectedElement;
            const frameRect = elements.previewFrame.getBoundingClientRect();
            const canvasRect = elements.canvasWrapper.getBoundingClientRect();

            // Get element rect relative to iframe
            const elementRect = element.getBoundingClientRect();

            // Calculate position relative to window
            const elementTop = canvasRect.top + (elementRect.top * state.zoom) + state.panY;
            const elementLeft = canvasRect.left + (elementRect.left * state.zoom) + state.panX;
            const elementWidth = elementRect.width * state.zoom;
            const elementHeight = elementRect.height * state.zoom;

            const toolbar = elements.quickActions;
            const toolbarRect = toolbar.getBoundingClientRect();
            const toolbarWidth = toolbarRect.width || 400; // Estimate if not yet visible
            const toolbarHeight = toolbarRect.height || 36;

            // Preferred position: centered above the element
            let x = elementLeft + (elementWidth / 2) - (toolbarWidth / 2);
            let y = elementTop - toolbarHeight - 8;

            // If above doesn't fit, try below
            if (y < 60) { // Below toolbar
                y = elementTop + elementHeight + 8;
            }

            // Clamp to viewport
            const padding = 8;
            x = Math.max(padding, Math.min(x, window.innerWidth - toolbarWidth - padding));
            y = Math.max(60, Math.min(y, window.innerHeight - toolbarHeight - padding));

            toolbar.style.left = x + 'px';
            toolbar.style.top = y + 'px';
        }

        function hideQuickActions() {
            elements.quickActions.classList.remove('visible');
            closeLayoutDropdown();
        }

        function closeLayoutDropdown() {
            elements.qaLayoutDropdown.classList.remove('open');
        }

        function handleQuickAction(action) {
            if (!state.selectedElement) return;

            const element = state.selectedElement;
            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;

            // Most actions need to save state first
            const needsSaveState = !['toggle-layout-menu'].includes(action);
            if (needsSaveState) {
                // Determine change type based on action category
                const layoutActions = ['center-h', 'center-v', 'full-width', 'reset-size', 'make-flex-row', 'make-flex-col', 'make-grid', 'make-block'];
                const changeType = layoutActions.includes(action) ? 'layout' : 'style';
                saveState(changeType);
            }

            switch (action) {
                // Centering
                case 'center-h':
                    element.style.marginLeft = 'auto';
                    element.style.marginRight = 'auto';
                    if (!element.style.display || element.style.display === 'inline') {
                        element.style.display = 'block';
                    }
                    showToast('success', 'Centered', 'Element centered horizontally');
                    break;

                case 'center-v':
                    const parent = element.parentElement;
                    if (parent && parent !== doc.body) {
                        parent.style.display = 'flex';
                        parent.style.alignItems = 'center';
                        showToast('success', 'Centered', 'Parent set to flex with vertical centering');
                    } else {
                        element.style.marginTop = 'auto';
                        element.style.marginBottom = 'auto';
                        showToast('info', 'Applied', 'Vertical margins set to auto');
                    }
                    break;

                case 'full-width':
                    element.style.width = '100%';
                    element.style.maxWidth = 'none';
                    showToast('success', 'Applied', 'Element set to full width');
                    break;

                case 'auto-size':
                    element.style.width = '';
                    element.style.height = '';
                    element.style.maxWidth = '';
                    element.style.maxHeight = '';
                    element.style.minWidth = '';
                    element.style.minHeight = '';
                    showToast('success', 'Reset', 'Size reset to auto');
                    break;

                // Transform
                case 'flip-h':
                    const currentScaleX = element.style.transform.includes('scaleX(-1)');
                    if (currentScaleX) {
                        element.style.transform = element.style.transform.replace('scaleX(-1)', '').trim() || '';
                    } else {
                        element.style.transform = (element.style.transform + ' scaleX(-1)').trim();
                    }
                    showToast('success', 'Flipped', 'Horizontal flip toggled');
                    break;

                case 'flip-v':
                    const currentScaleY = element.style.transform.includes('scaleY(-1)');
                    if (currentScaleY) {
                        element.style.transform = element.style.transform.replace('scaleY(-1)', '').trim() || '';
                    } else {
                        element.style.transform = (element.style.transform + ' scaleY(-1)').trim();
                    }
                    showToast('success', 'Flipped', 'Vertical flip toggled');
                    break;

                // Z-index
                case 'bring-front':
                    const computed = doc.defaultView.getComputedStyle(element);
                    const currentZ = parseInt(computed.zIndex) || 0;
                    element.style.zIndex = Math.max(currentZ + 1, 10);
                    element.style.position = element.style.position || 'relative';
                    showToast('success', 'Layered', 'Brought to front');
                    break;

                case 'send-back':
                    const computedBack = doc.defaultView.getComputedStyle(element);
                    const currentZBack = parseInt(computedBack.zIndex) || 0;
                    element.style.zIndex = Math.max(currentZBack - 1, -10);
                    element.style.position = element.style.position || 'relative';
                    showToast('success', 'Layered', 'Sent to back');
                    break;

                // Structure
                case 'wrap-div':
                    const wrapper = doc.createElement('div');
                    element.parentElement.insertBefore(wrapper, element);
                    wrapper.appendChild(element);
                    buildElementTree(doc.body);
                    // Select the wrapper
                    const wrapperPath = getElementPath(wrapper, doc.body);
                    selectElementByPath(wrapperPath);
                    showToast('success', 'Wrapped', 'Element wrapped in div');
                    break;

                case 'unwrap':
                    const parentToUnwrap = element.parentElement;
                    if (parentToUnwrap && parentToUnwrap !== doc.body) {
                        const grandparent = parentToUnwrap.parentElement;
                        if (grandparent) {
                            // Move all children of parent before the parent
                            while (parentToUnwrap.firstChild) {
                                grandparent.insertBefore(parentToUnwrap.firstChild, parentToUnwrap);
                            }
                            parentToUnwrap.remove();
                            buildElementTree(doc.body);
                            showToast('success', 'Unwrapped', 'Parent element removed');
                        }
                    } else {
                        showToast('warning', 'Cannot unwrap', 'Element has no removable parent');
                    }
                    break;

                // Layout
                case 'toggle-layout-menu':
                    elements.qaLayoutDropdown.classList.toggle('open');
                    return; // Don't close dropdown

                case 'make-flex':
                    element.style.display = 'flex';
                    element.style.flexDirection = 'row';
                    element.style.gap = '8px';
                    showToast('success', 'Layout', 'Converted to flex row');
                    break;

                case 'make-flex-col':
                    element.style.display = 'flex';
                    element.style.flexDirection = 'column';
                    element.style.gap = '8px';
                    showToast('success', 'Layout', 'Converted to flex column');
                    break;

                case 'make-grid':
                    element.style.display = 'grid';
                    element.style.gridTemplateColumns = 'repeat(auto-fit, minmax(100px, 1fr))';
                    element.style.gap = '8px';
                    showToast('success', 'Layout', 'Converted to grid');
                    break;

                case 'make-block':
                    element.style.display = 'block';
                    element.style.flexDirection = '';
                    element.style.gridTemplateColumns = '';
                    element.style.gap = '';
                    showToast('success', 'Layout', 'Converted to block');
                    break;

                // Image actions
                case 'img-contain':
                    element.style.objectFit = 'contain';
                    showToast('success', 'Applied', 'Object-fit: contain');
                    break;

                case 'img-cover':
                    element.style.objectFit = 'cover';
                    showToast('success', 'Applied', 'Object-fit: cover');
                    break;

                case 'img-fill':
                    element.style.objectFit = 'fill';
                    showToast('success', 'Applied', 'Object-fit: fill');
                    break;

                // Text actions
                case 'text-left':
                    element.style.textAlign = 'left';
                    showToast('success', 'Aligned', 'Text aligned left');
                    break;

                case 'text-center':
                    element.style.textAlign = 'center';
                    showToast('success', 'Aligned', 'Text aligned center');
                    break;

                case 'text-right':
                    element.style.textAlign = 'right';
                    showToast('success', 'Aligned', 'Text aligned right');
                    break;

                case 'text-bold':
                    const computedWeight = doc.defaultView.getComputedStyle(element).fontWeight;
                    const isBold = parseInt(computedWeight) >= 600;
                    element.style.fontWeight = isBold ? 'normal' : 'bold';
                    showToast('success', 'Style', isBold ? 'Bold removed' : 'Bold applied');
                    break;
            }

            closeLayoutDropdown();

            // Update property panel
            if (state.selectedElement) {
                showProperties(state.selectedElement);
            }

            // Re-position toolbar after style changes
            requestAnimationFrame(() => positionQuickActions());
        }

        // =========================================================================
        // Context Menu
        // =========================================================================

        function showContextMenu(x, y, element) {
            const menu = elements.contextMenu;

            // Update menu item states
            const pasteItem = menu.querySelector('[data-action="paste"]');
            const editTextItem = menu.querySelector('[data-action="edit-text"]');
            const moveUpItem = menu.querySelector('[data-action="move-up"]');
            const moveDownItem = menu.querySelector('[data-action="move-down"]');

            // Disable paste if clipboard empty
            pasteItem.classList.toggle('disabled', state.clipboard.length === 0);

            // Disable paste style if no style copied
            const pasteStyleItem = menu.querySelector('[data-action="paste-style"]');
            if (pasteStyleItem) {
                pasteStyleItem.classList.toggle('disabled', !state.styleClipboard);
            }

            // Disable edit text for elements without text content
            const hasTextContent = element && (
                element.childNodes.length === 0 ||
                (element.childNodes.length === 1 && element.childNodes[0].nodeType === 3)
            );
            editTextItem.classList.toggle('disabled', !hasTextContent);

            // Disable move up if first child
            const isFirst = element && element.parentElement && element === element.parentElement.firstElementChild;
            moveUpItem.classList.toggle('disabled', isFirst);

            // Disable move down if last child
            const isLast = element && element.parentElement && element === element.parentElement.lastElementChild;
            moveDownItem.classList.toggle('disabled', isLast);

            // Show "Duplicate Section" for section-type elements (slides)
            const duplicateSectionItem = menu.querySelector('[data-action="duplicate-section"]');
            if (duplicateSectionItem) {
                const sectionTags = ['SECTION', 'ARTICLE', 'ASIDE', 'HEADER', 'FOOTER', 'NAV', 'MAIN'];
                const isSection = element && (
                    sectionTags.includes(element.tagName) ||
                    (element.tagName === 'DIV' && element.classList.contains('slide')) ||
                    (element.tagName === 'DIV' && element.parentElement && element.parentElement.tagName === 'BODY')
                );
                duplicateSectionItem.style.display = isSection ? 'flex' : 'none';
            }

            // Position menu
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            // Show menu
            menu.classList.add('visible');

            // Adjust position if menu goes off screen
            requestAnimationFrame(() => {
                const rect = menu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    menu.style.left = (x - rect.width) + 'px';
                }
                if (rect.bottom > window.innerHeight) {
                    menu.style.top = (y - rect.height) + 'px';
                }
            });
        }

        function hideContextMenu() {
            elements.contextMenu.classList.remove('visible');
        }

        function handleContextMenuAction(action) {
            // Undo/Redo work without selection
            if (action === 'undo') {
                undo();
                hideContextMenu();
                return;
            }
            if (action === 'redo') {
                redo();
                hideContextMenu();
                return;
            }

            if (!state.selectedElement) return;

            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;

            switch (action) {
                case 'edit-text':
                    // Focus the text content input in properties panel
                    if (elements.propText) {
                        elements.propText.focus();
                        elements.propText.select();
                    }
                    break;

                case 'duplicate':
                    duplicateSelectedElement();
                    break;

                case 'duplicate-section':
                    if (duplicateSelectedElement()) {
                        showToast('success', 'Section Duplicated', 'New section added after the original');
                    }
                    break;

                case 'copy':
                    copySelectedElements();
                    showToast('info', 'Copied', 'Element copied to clipboard');
                    break;

                case 'paste':
                    pasteElements();
                    break;

                case 'move-up':
                    moveElementUp();
                    break;

                case 'move-down':
                    moveElementDown();
                    break;

                case 'delete':
                    deleteSelectedElement();
                    break;

                case 'copy-style':
                    copyStyle();
                    break;

                case 'paste-style':
                    pasteStyle();
                    break;
            }

            hideContextMenu();
        }

        function moveElementUp() {
            if (!state.selectedElement) return;

            const element = state.selectedElement;
            const parent = element.parentElement;
            const prev = element.previousElementSibling;

            if (!prev || element.tagName === 'BODY') return;

            saveState('move');
            parent.insertBefore(element, prev);

            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;
            buildElementTree(doc.body);

            // Reselect the element
            const newPath = getElementPath(element, doc.body);
            selectElementByPath(newPath);
        }

        function moveElementDown() {
            if (!state.selectedElement) return;

            const element = state.selectedElement;
            const parent = element.parentElement;
            const next = element.nextElementSibling;

            if (!next || element.tagName === 'BODY') return;

            saveState('move');
            parent.insertBefore(next, element);

            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;
            buildElementTree(doc.body);

            // Reselect the element
            const newPath = getElementPath(element, doc.body);
            selectElementByPath(newPath);
        }

        // =========================================================================
        // Sample HTML
        // =========================================================================

        const SAMPLE_HTML = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sample Landing Page</title>
</head>
<body style="margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh;">
    <header style="padding: 20px 40px; display: flex; justify-content: space-between; align-items: center;">
        <div style="color: white; font-size: 24px; font-weight: bold;">âœ¨ Acme</div>
        <nav style="display: flex; gap: 24px;">
            <a href="#" style="color: rgba(255,255,255,0.9); text-decoration: none;">Features</a>
            <a href="#" style="color: rgba(255,255,255,0.9); text-decoration: none;">Pricing</a>
            <a href="#" style="color: rgba(255,255,255,0.9); text-decoration: none;">About</a>
        </nav>
    </header>

    <main style="max-width: 800px; margin: 0 auto; padding: 80px 40px; text-align: center;">
        <h1 style="color: white; font-size: 48px; margin-bottom: 24px; font-weight: 700;">Build something amazing</h1>
        <p style="color: rgba(255,255,255,0.85); font-size: 20px; line-height: 1.6; margin-bottom: 40px;">The fastest way to create beautiful websites. No coding required. Just drag, drop, and publish.</p>

        <div style="display: flex; gap: 16px; justify-content: center; margin-bottom: 60px;">
            <button style="background: white; color: #667eea; border: none; padding: 16px 32px; font-size: 16px; font-weight: 600; border-radius: 8px; cursor: pointer;">Get Started Free</button>
            <button style="background: transparent; color: white; border: 2px solid rgba(255,255,255,0.5); padding: 16px 32px; font-size: 16px; font-weight: 600; border-radius: 8px; cursor: pointer;">Watch Demo</button>
        </div>

        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 24px; text-align: left;">
            <div style="background: rgba(255,255,255,0.1); padding: 24px; border-radius: 12px;">
                <div style="font-size: 32px; margin-bottom: 12px;">ðŸš€</div>
                <h3 style="color: white; margin: 0 0 8px 0; font-size: 18px;">Lightning Fast</h3>
                <p style="color: rgba(255,255,255,0.7); margin: 0; font-size: 14px; line-height: 1.5;">Built for speed. Your sites load in milliseconds.</p>
            </div>
            <div style="background: rgba(255,255,255,0.1); padding: 24px; border-radius: 12px;">
                <div style="font-size: 32px; margin-bottom: 12px;">ðŸŽ¨</div>
                <h3 style="color: white; margin: 0 0 8px 0; font-size: 18px;">Beautiful Design</h3>
                <p style="color: rgba(255,255,255,0.7); margin: 0; font-size: 14px; line-height: 1.5;">Stunning templates that look great everywhere.</p>
            </div>
            <div style="background: rgba(255,255,255,0.1); padding: 24px; border-radius: 12px;">
                <div style="font-size: 32px; margin-bottom: 12px;">ðŸ”’</div>
                <h3 style="color: white; margin: 0 0 8px 0; font-size: 18px;">Secure & Reliable</h3>
                <p style="color: rgba(255,255,255,0.7); margin: 0; font-size: 14px; line-height: 1.5;">Enterprise-grade security you can trust.</p>
            </div>
        </div>
    </main>

    <footer style="text-align: center; padding: 40px; color: rgba(255,255,255,0.6); font-size: 14px;">
        Â© 2024 Acme Inc. All rights reserved.
    </footer>
</body>
</html>`;

        function loadSampleHtml() {
            state.fileName = 'sample.html';
            state.originalHtml = SAMPLE_HTML;
            loadHtmlIntoFrame(state.originalHtml, true);

            elements.welcomeScreen.classList.add('hidden');
            elements.canvasWrapper.classList.remove('hidden');
            elements.btnExport.disabled = false;
            elements.btnInsert.disabled = false;
            state.documentLoaded = true;

            // Auto-fit to screen on load
            requestAnimationFrame(() => {
                fitToScreen();
            });

            // Scan for document colors
            setTimeout(() => {
                scanDocumentColors();
                scanDocumentFonts();
            }, 100);

            showToast('success', 'Sample loaded', 'Try selecting elements and editing their properties!');
        }

        // =========================================================================
        // Insert Element System
        // =========================================================================

        function toggleInsertMenu() {
            elements.insertMenu.classList.toggle('open');
        }

        function closeInsertMenu() {
            elements.insertMenu.classList.remove('open');
        }

        function insertElement(tagName) {
            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;

            // Create the new element
            const newElement = doc.createElement(tagName);

            // Add default content/attributes based on tag type
            const defaults = {
                'div': { text: '', style: 'padding: 10px; min-height: 20px;' },
                'p': { text: 'New paragraph' },
                'span': { text: 'New span' },
                'h1': { text: 'Heading 1' },
                'h2': { text: 'Heading 2' },
                'h3': { text: 'Heading 3' },
                'h4': { text: 'Heading 4' },
                'h5': { text: 'Heading 5' },
                'h6': { text: 'Heading 6' },
                'button': { text: 'Button' },
                'a': { text: 'Link', attrs: { href: '#' } },
                'img': { attrs: { src: 'https://via.placeholder.com/150', alt: 'Image' } },
                'input': { attrs: { type: 'text', placeholder: 'Enter text...' } },
                'ul': { children: ['li'] },
                'ol': { children: ['li'] },
                'li': { text: 'List item' },
                'section': { style: 'padding: 20px;' },
                'header': { style: 'padding: 20px;' },
                'footer': { style: 'padding: 20px;' },
                'nav': { style: 'padding: 10px;' }
            };

            const def = defaults[tagName] || {};

            if (def.text) {
                newElement.textContent = def.text;
            }

            if (def.style) {
                newElement.style.cssText = def.style;
            }

            if (def.attrs) {
                for (const [key, value] of Object.entries(def.attrs)) {
                    newElement.setAttribute(key, value);
                }
            }

            // For lists, add a child item
            if (def.children) {
                def.children.forEach(childTag => {
                    const child = doc.createElement(childTag);
                    child.textContent = 'List item';
                    newElement.appendChild(child);
                });
            }

            // Save state before modification
            saveState('add');

            // Insert into DOM
            let parentElement;
            if (state.selectedElement && state.selectedElement !== doc.body) {
                // Insert as child of selected element
                parentElement = state.selectedElement;
            } else {
                // Insert at body
                parentElement = doc.body;
            }

            parentElement.appendChild(newElement);

            // Rebuild tree and select new element
            buildElementTree(doc.body);
            const newPath = getElementPath(newElement, doc.body);
            selectElementByPath(newPath);

            closeInsertMenu();
        }

        // Template definitions for pre-styled components
        const templates = {
            slide: `<section style="padding: 60px 40px; min-height: 400px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                <h1 style="color: white; font-size: 48px; margin-bottom: 20px;">Slide Title</h1>
                <p style="color: rgba(255,255,255,0.9); font-size: 24px; max-width: 600px;">Add your content here. This is a presentation slide template.</p>
            </section>`,
            
            card: `<div style="background: white; border-radius: 12px; padding: 24px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); max-width: 400px;">
                <h3 style="color: #1a1a2e; margin-bottom: 12px; font-size: 20px;">Card Title</h3>
                <p style="color: #666; line-height: 1.6;">This is a card component. Great for featuring content, testimonials, or product info.</p>
                <button style="background: #667eea; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; margin-top: 16px;">Learn More</button>
            </div>`,
            
            hero: `<section style="padding: 80px 40px; min-height: 500px; background: #1a1a2e; text-align: center; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                <h1 style="color: white; font-size: 56px; margin-bottom: 24px; max-width: 800px;">Your Big Headline Here</h1>
                <p style="color: rgba(255,255,255,0.8); font-size: 20px; max-width: 600px; margin-bottom: 32px;">A compelling subheadline that explains your value proposition.</p>
                <button style="background: #667eea; color: white; border: none; padding: 16px 32px; border-radius: 8px; font-size: 18px; cursor: pointer;">Get Started</button>
            </section>`,
            
            'two-column': `<div style="display: flex; gap: 40px; padding: 40px;">
                <div style="flex: 1;">
                    <h2 style="color: #1a1a2e; margin-bottom: 16px;">Left Column</h2>
                    <p style="color: #666; line-height: 1.6;">Content for the left side. You can add text, images, or other elements here.</p>
                </div>
                <div style="flex: 1;">
                    <h2 style="color: #1a1a2e; margin-bottom: 16px;">Right Column</h2>
                    <p style="color: #666; line-height: 1.6;">Content for the right side. Perfect for comparisons or side-by-side layouts.</p>
                </div>
            </div>`,
            
            cta: `<div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); padding: 48px; text-align: center; border-radius: 16px;">
                <h2 style="color: white; font-size: 32px; margin-bottom: 16px;">Ready to Get Started?</h2>
                <p style="color: rgba(255,255,255,0.9); font-size: 18px; margin-bottom: 24px;">Join thousands of users who already love our product.</p>
                <button style="background: white; color: #f5576c; border: none; padding: 14px 28px; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer;">Sign Up Free</button>
            </div>`
        };

        function insertTemplate(templateName) {
            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;
            
            const templateHtml = templates[templateName];
            if (!templateHtml) return;
            
            // Create a temporary container to parse the HTML
            const temp = doc.createElement('div');
            temp.innerHTML = templateHtml.trim();
            const newElement = temp.firstElementChild;
            
            if (!newElement) return;

            // Save state for undo
            saveState('add');

            // Determine where to insert
            let parentElement;
            if (state.selectedElement && state.selectedElement.tagName !== 'BODY') {
                parentElement = state.selectedElement.parentElement || doc.body;
                // Insert after selected element
                state.selectedElement.parentElement.insertBefore(newElement, state.selectedElement.nextSibling);
            } else {
                parentElement = doc.body;
                parentElement.appendChild(newElement);
            }
            
            // Rebuild tree and select new element
            buildElementTree(doc.body);
            const newPath = getElementPath(newElement, doc.body);
            selectElementByPath(newPath);
            
            closeInsertMenu();
            showToast('success', 'Template Added', 'New ' + templateName + ' inserted');
        }

        // =========================================================================
        // Zoom & Pan System
        // =========================================================================

        function updateTransform(smooth = true) {
            if (smooth) {
                elements.canvasTransform.classList.remove('no-transition');
            } else {
                elements.canvasTransform.classList.add('no-transition');
            }
            elements.canvasTransform.style.transform =
                `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`;
            elements.zoomLevel.textContent = Math.round(state.zoom * 100) + '%';

            // Update resize overlay position after zoom/pan
            requestAnimationFrame(updateResizeOverlay);
            requestAnimationFrame(updateSpacingOverlay);
        }

        function zoomTo(newZoom, centerX, centerY) {
            const oldZoom = state.zoom;
            newZoom = Math.max(state.minZoom, Math.min(state.maxZoom, newZoom));

            if (newZoom === oldZoom) return;

            // If center point provided, zoom towards that point
            if (centerX !== undefined && centerY !== undefined) {
                // Convert viewport coords to canvas coords
                const canvasX = (centerX - state.panX) / oldZoom;
                const canvasY = (centerY - state.panY) / oldZoom;

                // After zoom, we want the same canvas point under the cursor
                state.panX = centerX - canvasX * newZoom;
                state.panY = centerY - canvasY * newZoom;
            }

            state.zoom = newZoom;
            updateTransform();
        }

        function zoomIn(centerX, centerY) {
            zoomTo(state.zoom * 1.2, centerX, centerY);
        }

        function zoomOut(centerX, centerY) {
            zoomTo(state.zoom / 1.2, centerX, centerY);
        }

        function resetZoom() {
            state.zoom = 1;
            centerCanvas();
        }

        function fitToScreen() {
            const viewport = elements.canvasViewport.getBoundingClientRect();
            // Use actual frame dimensions
            const frameWidth = parseInt(elements.previewFrame.width) || 800;
            const frameHeight = parseInt(elements.previewFrame.height) || 600;
            const padding = 60;

            const scaleX = (viewport.width - padding * 2) / frameWidth;
            const scaleY = (viewport.height - padding * 2) / frameHeight;
            // Allow zoom out past 100% to fit large content
            const scale = Math.min(scaleX, scaleY);

            state.zoom = Math.max(state.minZoom, Math.min(state.maxZoom, scale));
            centerCanvas();
        }

        function centerCanvas() {
            const viewport = elements.canvasViewport.getBoundingClientRect();
            const frameWidth = (parseInt(elements.previewFrame.width) || 800) * state.zoom;
            const frameHeight = (parseInt(elements.previewFrame.height) || 600) * state.zoom;

            state.panX = (viewport.width - frameWidth) / 2;
            state.panY = (viewport.height - frameHeight) / 2;
            updateTransform();
        }

        function handleWheel(e) {
            // Only handle zoom when over canvas area
            if (!elements.canvasArea.contains(e.target) && e.target !== elements.canvasArea) {
                return;
            }

            // If space is down, scroll wheel zooms (Figma-style)
            // Otherwise, ctrl+scroll zooms, plain scroll does nothing (allow page scroll)
            const shouldZoom = state.isSpaceDown || e.ctrlKey || e.metaKey;
            
            if (!shouldZoom) {
                return; // Allow normal scroll behavior
            }

            e.preventDefault();

            const rect = elements.canvasViewport.getBoundingClientRect();
            const centerX = e.clientX - rect.left;
            const centerY = e.clientY - rect.top;

            // Smooth zoom factor based on scroll delta
            const delta = -e.deltaY;
            const zoomFactor = Math.pow(1.002, delta);

            // Disable transition for wheel zoom (smoother continuous zoom)
            elements.canvasTransform.classList.add('no-transition');
            zoomTo(state.zoom * zoomFactor, centerX, centerY);
        }

        function startPan(e) {
            if (!state.isSpaceDown) return;

            state.isPanning = true;
            state.lastMouseX = e.clientX;
            state.lastMouseY = e.clientY;
            elements.canvasArea.classList.add('panning');
            elements.canvasTransform.classList.add('no-transition');
            e.preventDefault();
        }

        function doPan(e) {
            if (!state.isPanning) return;

            const deltaX = e.clientX - state.lastMouseX;
            const deltaY = e.clientY - state.lastMouseY;

            state.panX += deltaX;
            state.panY += deltaY;
            state.lastMouseX = e.clientX;
            state.lastMouseY = e.clientY;

            updateTransform(false);
        }

        function endPan() {
            state.isPanning = false;
            elements.canvasArea.classList.remove('panning');
        }

        // =========================================================================
        // Undo/Redo System
        // =========================================================================

        // Change type labels for user-friendly undo/redo descriptions
        const CHANGE_TYPES = {
            'style': 'style change',
            'text': 'text edit',
            'delete': 'delete',
            'add': 'add element',
            'move': 'move',
            'duplicate': 'duplicate',
            'paste': 'paste',
            'layout': 'layout change',
            'resize': 'resize',
            'spacing': 'spacing change',
            'default': 'change'
        };

        function saveState(changeType = 'default') {
            const html = getFrameHtml();
            const lastEntry = state.undoStack[state.undoStack.length - 1];
            const lastHtml = lastEntry ? (lastEntry.html || lastEntry) : null;

            if (html === lastHtml) return;

            state.undoStack.push({ html, type: changeType });
            if (state.undoStack.length > state.maxUndoSteps) {
                state.undoStack.shift();
            }
            state.redoStack = [];
            updateUndoButtons();
        }

        function undo() {
            if (state.undoStack.length <= 1) return;

            const current = state.undoStack.pop();
            state.redoStack.push(current);

            const previous = state.undoStack[state.undoStack.length - 1];
            const html = previous.html || previous;
            loadHtmlIntoFrame(html, false);
            updateUndoButtons();

            // Show toast for undo action
            const type = current.type || 'default';
            showToast('info', 'Undo', `Undid ${CHANGE_TYPES[type] || type}`);
        }

        function redo() {
            if (state.redoStack.length === 0) return;

            const next = state.redoStack.pop();
            state.undoStack.push(next);

            const html = next.html || next;
            loadHtmlIntoFrame(html, false);
            updateUndoButtons();

            // Show toast for redo action
            const type = next.type || 'default';
            showToast('info', 'Redo', `Redid ${CHANGE_TYPES[type] || type}`);
        }

        function getUndoLabel() {
            if (state.undoStack.length <= 1) return 'Undo';
            const entry = state.undoStack[state.undoStack.length - 1];
            const type = entry.type || 'default';
            return `Undo ${CHANGE_TYPES[type] || type}`;
        }

        function getRedoLabel() {
            if (state.redoStack.length === 0) return 'Redo';
            const entry = state.redoStack[state.redoStack.length - 1];
            const type = entry.type || 'default';
            return `Redo ${CHANGE_TYPES[type] || type}`;
        }

        function updateUndoButtons() {
            elements.btnUndo.disabled = state.undoStack.length <= 1;
            elements.btnRedo.disabled = state.redoStack.length === 0;

            // Update button titles with descriptive labels
            elements.btnUndo.title = getUndoLabel();
            elements.btnRedo.title = getRedoLabel();

            // Update context menu items if they exist
            const ctxUndo = document.getElementById('ctx-undo');
            const ctxRedo = document.getElementById('ctx-redo');
            if (ctxUndo) {
                ctxUndo.querySelector('.context-menu-item-label').textContent = getUndoLabel();
                ctxUndo.classList.toggle('disabled', state.undoStack.length <= 1);
            }
            if (ctxRedo) {
                ctxRedo.querySelector('.context-menu-item-label').textContent = getRedoLabel();
                ctxRedo.classList.toggle('disabled', state.redoStack.length === 0);
            }
        }

        // =========================================================================
        // File Handling
        // =========================================================================

        // File size limits
        const MAX_FILE_SIZE = 1024 * 1024; // 1MB
        const LARGE_FILE_WARNING = 500 * 1024; // 500KB

        function handleFile(file) {
            // 1. Check if file exists
            if (!file) {
                showToast('error', 'No file selected', 'Please select or drop a file.');
                return;
            }

            // 2. Check file extension
            if (!file.name.match(/\.html?$/i)) {
                showToast('error', 'Invalid file type', `"${file.name}" is not an HTML file. Please select a .html or .htm file.`);
                return;
            }

            // 3. Check file size
            if (file.size > MAX_FILE_SIZE) {
                const sizeMB = (file.size / (1024 * 1024)).toFixed(2);
                showToast('error', 'File too large', `File is ${sizeMB}MB. Maximum supported size is 1MB for smooth editing.`);
                return;
            }

            // 4. Check for empty file
            if (file.size === 0) {
                showToast('error', 'Empty file', 'The file is empty. Please select an HTML file with content.');
                return;
            }

            state.fileName = file.name;

            const reader = new FileReader();

            reader.onerror = () => {
                showToast('error', 'Read error', 'Could not read the file. Please try again.');
            };

            reader.onload = (e) => {
                const content = e.target.result;

                // 5. Check for binary content (non-text)
                if (isBinaryContent(content)) {
                    showToast('error', 'Binary file detected', 'This appears to be a binary file, not HTML. Please select a text-based HTML file.');
                    return;
                }

                // 6. Validate HTML structure
                const validation = validateHtml(content);
                if (!validation.valid) {
                    showToast('error', 'Invalid HTML', validation.message);
                    return;
                }

                // 7. Large file warning
                if (file.size > LARGE_FILE_WARNING) {
                    const sizeKB = Math.round(file.size / 1024);
                    showToast('warning', 'Large file', `File is ${sizeKB}KB. Editing may be slower with many elements.`);
                }

                // 8. Script warning
                if (hasScripts(content)) {
                    showToast('warning', 'Scripts detected', 'This file contains JavaScript. Scripts are preserved but won\'t execute in the editor.');
                }

                // 9. Element count warning
                const elementCount = countElements(content);
                if (elementCount > 500) {
                    showToast('warning', 'Many elements', `File contains ${elementCount} elements. Consider simplifying for better performance.`);
                }

                state.originalHtml = content;
                loadHtmlIntoFrame(state.originalHtml, true);

                elements.welcomeScreen.classList.add('hidden');
                elements.canvasWrapper.classList.remove('hidden');
                elements.btnExport.disabled = false;
                elements.btnInsert.disabled = false;
                state.documentLoaded = true;

                // Auto-fit to screen on load
                requestAnimationFrame(() => {
                    fitToScreen();
                });

                // Scan for document colors
                setTimeout(() => {
                scanDocumentColors();
                scanDocumentFonts();
            }, 100);

                showToast('success', 'File loaded', `${file.name} loaded successfully.`);
            };

            reader.readAsText(file);
        }

        function isBinaryContent(content) {
            // Check for null bytes or high concentration of non-printable chars
            const sample = content.slice(0, 1000);
            let nonPrintable = 0;
            for (let i = 0; i < sample.length; i++) {
                const code = sample.charCodeAt(i);
                if (code === 0 || (code < 32 && code !== 9 && code !== 10 && code !== 13)) {
                    nonPrintable++;
                }
            }
            return nonPrintable > sample.length * 0.1; // More than 10% non-printable
        }

        function validateHtml(content) {
            const trimmed = content.trim();

            // Empty after trim
            if (!trimmed) {
                return { valid: false, message: 'File contains only whitespace.' };
            }

            // Must contain at least some HTML-like content
            const hasHtmlTag = /<html[\s>]/i.test(trimmed);
            const hasBodyTag = /<body[\s>]/i.test(trimmed);
            const hasAnyTag = /<[a-z][^>]*>/i.test(trimmed);

            if (!hasAnyTag) {
                return { valid: false, message: 'No HTML tags found. This doesn\'t appear to be an HTML file.' };
            }

            // Try parsing to check for severe malformation
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(trimmed, 'text/html');

                // Check for parser errors
                const parserError = doc.querySelector('parsererror');
                if (parserError) {
                    return { valid: false, message: 'HTML parsing failed. The file may be malformed.' };
                }

                // Must have a body with content
                if (!doc.body || doc.body.children.length === 0) {
                    // Allow if there's text content at least
                    if (!doc.body || !doc.body.textContent.trim()) {
                        return { valid: false, message: 'HTML has no visible content in the body.' };
                    }
                }
            } catch (e) {
                return { valid: false, message: 'Failed to parse HTML: ' + e.message };
            }

            return { valid: true };
        }

        function hasScripts(content) {
            return /<script[\s>]/i.test(content);
        }

        function countElements(content) {
            const matches = content.match(/<[a-z][^>]*>/gi);
            return matches ? matches.length : 0;
        }

        function loadHtmlIntoFrame(html, resetUndo = false) {
            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;

            doc.open();
            doc.write(html);
            doc.close();

            // Add editor styles to iframe
            const style = doc.createElement('style');
            style.id = 'editor-styles';
            style.textContent = `.editor-selected { outline: 2px solid #0078d4 !important; outline-offset: 2px; }
                .editor-hover { outline: 1px dashed #0078d4 !important; }
                [contenteditable="true"] { outline: 2px solid #8b5cf6 !important; outline-offset: 2px; background: rgba(139, 92, 246, 0.1) !important; cursor: text !important; }
                [contenteditable="true"]:focus { box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.2) !important; }
                h1, h2, h3, h4, h5, h6, p, span, a, li, td, th, label { cursor: text; }`;
            doc.head.appendChild(style);

            setupFrameListeners(doc);
            buildElementTree(doc.body);
            clearSelection();

            if (resetUndo) {
                state.undoStack = [html];
                state.redoStack = [];
                updateUndoButtons();
            }
        }

        function getFrameHtml() {
            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;

            const clone = doc.documentElement.cloneNode(true);
            const editorStyle = clone.querySelector('#editor-styles');
            if (editorStyle) editorStyle.remove();

            clone.querySelectorAll('.editor-selected, .editor-hover').forEach(el => {
                el.classList.remove('editor-selected', 'editor-hover');
            });

            return '<!DOCTYPE html>\n' + clone.outerHTML;
        }

        function exportHtml() {
            const html = getFrameHtml();
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = state.fileName.replace(/\.html?$/i, '') + '_edited.html';
            a.click();

            URL.revokeObjectURL(url);
        }

        // =========================================================================
        // Element Tree
        // =========================================================================

        // Optimized buildElementTree with virtual scrolling for large DOMs
        function buildElementTree(root) {
            const startTime = performance.now();

            // First, flatten the DOM tree into an array for virtual scrolling
            state.treeData = [];

            function collectNodes(element, depth, path) {
                if (element.nodeType !== 1) return;
                if (element.tagName === 'SCRIPT' || element.tagName === 'STYLE') return;

                const id = element.id ? '#' + element.id : '';
                const cls = element.className && typeof element.className === 'string'
                    ? (element.className.split(' ').filter(c => c && !c.startsWith('editor-')).slice(0, 1)[0] ? '.' + element.className.split(' ').filter(c => c && !c.startsWith('editor-'))[0] : '')
                    : '';

                state.treeData.push({
                    element: element,
                    depth: depth,
                    path: path,
                    tagName: element.tagName,
                    label: getFriendlyName(element.tagName) + id + cls
                });

                Array.from(element.children).forEach((child, i) => {
                    collectNodes(child, depth + 1, [...path, i]);
                });
            }

            collectNodes(root, 0, []);

            // Set up virtual scrolling container
            const container = elements.elementTree;
            const itemHeight = state.treeItemHeight;
            const totalHeight = state.treeData.length * itemHeight;

            // Clear and set up the container
            container.innerHTML = '';
            container.style.position = 'relative';
            container.style.height = '100%';
            container.style.overflowY = 'auto';

            // Create spacer for total height
            const spacer = document.createElement('div');
            spacer.style.height = totalHeight + 'px';
            spacer.style.width = '1px';
            spacer.style.position = 'absolute';
            spacer.style.top = '0';
            spacer.style.left = '0';
            spacer.style.pointerEvents = 'none';
            container.appendChild(spacer);

            // Content container for visible items
            const content = document.createElement('div');
            content.className = 'tree-content';
            content.style.position = 'absolute';
            content.style.top = '0';
            content.style.left = '0';
            content.style.right = '0';
            container.appendChild(content);

            // Render visible items
            function renderVisibleItems() {
                const scrollTop = container.scrollTop;
                const containerHeight = container.clientHeight;
                const buffer = state.treeBuffer;

                const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - buffer);
                const endIndex = Math.min(state.treeData.length, Math.ceil((scrollTop + containerHeight) / itemHeight) + buffer);

                // Only re-render if viewport changed significantly
                if (startIndex === state.visibleTreeStart && endIndex === state.visibleTreeEnd) {
                    return;
                }

                state.visibleTreeStart = startIndex;
                state.visibleTreeEnd = endIndex;

                // Use DocumentFragment for batch DOM insertion
                const fragment = document.createDocumentFragment();

                for (let i = startIndex; i < endIndex; i++) {
                    const item = state.treeData[i];
                    const node = createTreeNode(item, i);
                    fragment.appendChild(node);
                }

                content.innerHTML = '';
                content.style.transform = `translateY(${startIndex * itemHeight}px)`;
                content.appendChild(fragment);
            }

            // Throttled scroll handler
            const handleScroll = throttle(renderVisibleItems, 16);
            container.addEventListener('scroll', handleScroll);

            // Initial render
            renderVisibleItems();

            const elapsed = performance.now() - startTime;
            if (elapsed > 100) {
                console.log(`Tree built: ${state.treeData.length} nodes in ${elapsed.toFixed(1)}ms`);
            }
        }

        // Create a single tree node element
        function createTreeNode(item, index) {
            const { element, depth, path, tagName, label } = item;
            const itemHeight = state.treeItemHeight;

            const node = document.createElement('div');
            node.className = 'tree-node';
            node.dataset.path = path.join(',');
            node.dataset.index = index;
            node.draggable = path.length > 0;
            node.style.height = itemHeight + 'px';

            // Check if this node is selected
            if (state.selectedPaths.some(sp => pathsEqual(sp, path))) {
                node.classList.add('selected');
            }

            const indent = document.createElement('span');
            indent.className = 'tree-node-indent';
            indent.style.width = (depth * 16) + 'px';

            const icon = document.createElement('span');
            icon.className = 'tree-node-icon';
            icon.textContent = getElementIcon(tagName);

            const labelSpan = document.createElement('span');
            labelSpan.textContent = label;

            node.appendChild(indent);
            node.appendChild(icon);
            node.appendChild(labelSpan);

            // Event delegation - attach handlers
            node.addEventListener('click', (e) => {
                if (!e.defaultPrevented) {
                    selectElementByPath(path, {
                        addToSelection: e.shiftKey,
                        toggleSelection: e.ctrlKey || e.metaKey,
                        scrollToElement: true  // Scroll canvas to show element
                    });
                }
            });

            // Drag and drop handlers
            node.addEventListener('dragstart', (e) => {
                if (path.length === 0) {
                    e.preventDefault();
                    return;
                }
                state.draggedPath = path;
                state.isAltDrag = e.altKey;
                node.classList.add(state.isAltDrag ? 'cloning' : 'dragging');
                e.dataTransfer.effectAllowed = state.isAltDrag ? 'copy' : 'move';
                e.dataTransfer.setData('text/plain', path.join(','));
            });

            node.addEventListener('dragend', () => {
                node.classList.remove('dragging', 'cloning');
                state.draggedPath = null;
                state.isAltDrag = false;
                clearDragIndicators();
            });

            node.addEventListener('dragover', (e) => {
                e.preventDefault();
                if (!state.draggedPath) return;

                if (isDescendantPath(path, state.draggedPath)) return;
                if (!state.isAltDrag && !e.altKey && pathsEqual(path, state.draggedPath)) return;

                clearDragIndicators();

                const rect = node.getBoundingClientRect();
                const y = e.clientY - rect.top;
                const height = rect.height;

                if (e.altKey || state.isAltDrag) {
                    node.classList.add('clone-target');
                }

                if (y < height * 0.25) {
                    node.classList.add('drag-over-before');
                } else if (y > height * 0.75) {
                    node.classList.add('drag-over-after');
                } else {
                    node.classList.add('drag-over-inside');
                }
            });

            node.addEventListener('dragleave', () => {
                node.classList.remove('drag-over-before', 'drag-over-after', 'drag-over-inside', 'clone-target');
            });

            node.addEventListener('drop', (e) => {
                e.preventDefault();
                clearDragIndicators();

                if (!state.draggedPath) return;

                const isCloning = e.altKey || state.isAltDrag;
                if (isDescendantPath(path, state.draggedPath)) return;
                if (!isCloning && pathsEqual(path, state.draggedPath)) return;

                const rect = node.getBoundingClientRect();
                const y = e.clientY - rect.top;
                const height = rect.height;

                let dropPosition;
                if (y < height * 0.25) {
                    dropPosition = 'before';
                } else if (y > height * 0.75) {
                    dropPosition = 'after';
                } else {
                    dropPosition = 'inside';
                }

                if (isCloning) {
                    cloneElementToPosition(state.draggedPath, path, dropPosition);
                } else {
                    moveElement(state.draggedPath, path, dropPosition);
                }
            });

            return node;
        }

        // Optimized version for scheduled renders
        function buildElementTreeOptimized(root) {
            buildElementTree(root);
        }

        function clearDragIndicators() {
            document.querySelectorAll('.tree-node').forEach(n => {
                n.classList.remove('drag-over-before', 'drag-over-after', 'drag-over-inside', 'clone-target');
            });
        }

        function pathsEqual(path1, path2) {
            if (path1.length !== path2.length) return false;
            return path1.every((v, i) => v === path2[i]);
        }

        function isDescendantPath(potentialDescendant, potentialAncestor) {
            if (potentialDescendant.length <= potentialAncestor.length) return false;
            return potentialAncestor.every((v, i) => v === potentialDescendant[i]);
        }

        function moveElement(sourcePath, targetPath, dropPosition) {
            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;

            const sourceElement = getElementByPath(sourcePath);
            const targetElement = getElementByPath(targetPath);

            if (!sourceElement || !targetElement) return;

            saveState('move');

            sourceElement.classList.remove('editor-selected', 'editor-hover');

            if (dropPosition === 'inside') {
                targetElement.appendChild(sourceElement);
            } else if (dropPosition === 'before') {
                targetElement.parentElement.insertBefore(sourceElement, targetElement);
            } else if (dropPosition === 'after') {
                if (targetElement.nextSibling) {
                    targetElement.parentElement.insertBefore(sourceElement, targetElement.nextSibling);
                } else {
                    targetElement.parentElement.appendChild(sourceElement);
                }
            }

            buildElementTree(doc.body);

            // Reselect the moved element
            const newPath = getElementPath(sourceElement, doc.body);
            selectElementByPath(newPath);
        }

        // Clone element to a specific position (Alt+drag)
        function cloneElementToPosition(sourcePath, targetPath, dropPosition) {
            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;

            const sourceElement = getElementByPath(sourcePath);
            const targetElement = getElementByPath(targetPath);

            if (!sourceElement || !targetElement) return;

            const tag = sourceElement.tagName.toUpperCase();
            if (tag === 'BODY' || tag === 'HTML' || tag === 'HEAD') return;

            saveState('duplicate');

            // Clone the element
            const clone = sourceElement.cloneNode(true);
            clone.classList.remove('editor-selected', 'editor-hover');

            if (dropPosition === 'inside') {
                targetElement.appendChild(clone);
            } else if (dropPosition === 'before') {
                targetElement.parentElement.insertBefore(clone, targetElement);
            } else if (dropPosition === 'after') {
                if (targetElement.nextSibling) {
                    targetElement.parentElement.insertBefore(clone, targetElement.nextSibling);
                } else {
                    targetElement.parentElement.appendChild(clone);
                }
            }

            buildElementTree(doc.body);

            // Select the cloned element
            const newPath = getElementPath(clone, doc.body);
            selectElementByPath(newPath);
        }

        // Friendly names for HTML elements (for non-technical users)
        function getFriendlyName(tagName) {
            const names = {
                'DIV': 'Container',
                'SPAN': 'Text',
                'P': 'Paragraph',
                'H1': 'Title',
                'H2': 'Subtitle',
                'H3': 'Heading',
                'H4': 'Heading',
                'H5': 'Heading',
                'H6': 'Heading',
                'A': 'Link',
                'IMG': 'Image',
                'BUTTON': 'Button',
                'INPUT': 'Input Field',
                'TEXTAREA': 'Text Area',
                'SELECT': 'Dropdown',
                'FORM': 'Form',
                'UL': 'Bullet List',
                'OL': 'Numbered List',
                'LI': 'List Item',
                'TABLE': 'Table',
                'TR': 'Table Row',
                'TD': 'Table Cell',
                'TH': 'Table Header',
                'THEAD': 'Table Head',
                'TBODY': 'Table Body',
                'HEADER': 'Header',
                'FOOTER': 'Footer',
                'NAV': 'Navigation',
                'SECTION': 'Page Section',
                'ARTICLE': 'Article',
                'ASIDE': 'Sidebar',
                'MAIN': 'Main Content',
                'BODY': 'Page Body',
                'LABEL': 'Label',
                'STRONG': 'Bold Text',
                'EM': 'Italic Text',
                'B': 'Bold',
                'I': 'Italic',
                'U': 'Underline',
                'BR': 'Line Break',
                'HR': 'Divider',
                'BLOCKQUOTE': 'Quote',
                'CODE': 'Code',
                'PRE': 'Code Block',
                'VIDEO': 'Video',
                'AUDIO': 'Audio',
                'IFRAME': 'Embedded Frame',
                'CANVAS': 'Canvas',
                'SVG': 'Vector Graphic',
                'FIGURE': 'Figure',
                'FIGCAPTION': 'Caption'
            };
            const friendly = names[tagName];
            if (friendly) {
                // Show "Title (h1)" format for headings, just friendly name for others
                if (tagName.match(/^H[1-6]$/)) {
                    return friendly + ' (' + tagName.toLowerCase() + ')';
                }
                return friendly;
            }
            return tagName.toLowerCase();
        }

        function getElementIcon(tagName) {
            const icons = {
                'DIV': 'â–¢', 'SPAN': 'âŠ¡', 'P': 'Â¶', 'H1': 'H1', 'H2': 'H2', 'H3': 'H3',
                'H4': 'H4', 'H5': 'H5', 'H6': 'H6', 'A': 'ðŸ”—', 'IMG': 'ðŸ–¼', 'BUTTON': 'âŠž',
                'INPUT': 'âŠŸ', 'FORM': 'ðŸ“‹', 'UL': 'â€¢', 'OL': '1.', 'LI': 'Â·', 'TABLE': 'âŠž',
                'HEADER': 'â–¤', 'FOOTER': 'â–¥', 'NAV': 'â˜°', 'SECTION': 'Â§', 'ARTICLE': 'ðŸ“„', 'BODY': 'â—‰'
            };
            return icons[tagName] || 'â—‡';
        }

        // =========================================================================
        // Element Search
        // =========================================================================

        function filterElementTree(query) {
            const nodes = elements.elementTree.querySelectorAll('.tree-node');
            const trimmedQuery = query.trim().toLowerCase();

            if (!trimmedQuery) {
                // Clear search - show all nodes
                nodes.forEach(node => {
                    node.classList.remove('search-hidden', 'search-match');
                    // Restore original label
                    const label = node.querySelector('span:last-child');
                    if (label && label.dataset.originalText) {
                        label.textContent = label.dataset.originalText;
                    }
                });
                elements.treeSearchCount.classList.remove('visible');
                elements.treeSearchWrapper.classList.remove('has-value');
                return;
            }

            elements.treeSearchWrapper.classList.add('has-value');

            let matchCount = 0;
            const matchedPaths = new Set();

            // First pass: find matches and collect their paths
            nodes.forEach(node => {
                const label = node.querySelector('span:last-child');
                if (!label) return;

                // Store original text
                if (!label.dataset.originalText) {
                    label.dataset.originalText = label.textContent;
                }

                const text = label.dataset.originalText.toLowerCase();
                const isMatch = text.includes(trimmedQuery);

                if (isMatch) {
                    matchCount++;
                    // Store this path and all ancestor paths
                    const path = node.dataset.path;
                    if (path) {
                        matchedPaths.add(path);
                        // Add ancestor paths
                        const parts = path.split(',').map(Number);
                        for (let i = 1; i < parts.length; i++) {
                            matchedPaths.add(parts.slice(0, i).join(','));
                        }
                    }
                }
            });

            // Second pass: show/hide and highlight
            nodes.forEach(node => {
                const label = node.querySelector('span:last-child');
                if (!label) return;

                const path = node.dataset.path;
                const text = label.dataset.originalText;
                const textLower = text.toLowerCase();
                const isMatch = textLower.includes(trimmedQuery);
                const isAncestor = matchedPaths.has(path);

                if (isMatch || isAncestor) {
                    node.classList.remove('search-hidden');

                    if (isMatch) {
                        node.classList.add('search-match');
                        // Highlight matching text
                        const startIndex = textLower.indexOf(trimmedQuery);
                        const endIndex = startIndex + trimmedQuery.length;
                        const before = text.substring(0, startIndex);
                        const match = text.substring(startIndex, endIndex);
                        const after = text.substring(endIndex);
                        label.innerHTML = before + '<span class="tree-node-highlight">' + match + '</span>' + after;
                    } else {
                        node.classList.remove('search-match');
                        label.textContent = text;
                    }
                } else {
                    node.classList.add('search-hidden');
                    node.classList.remove('search-match');
                    label.textContent = text;
                }
            });

            // Update count display
            elements.treeSearchCount.textContent = matchCount + ' match' + (matchCount !== 1 ? 'es' : '');
            elements.treeSearchCount.classList.add('visible');
        }

        function clearTreeSearch() {
            elements.treeSearchInput.value = '';
            if (state.searchMode === 'elements') {
                filterElementTree('');
            } else {
                clearTextSearchResults();
            }
            elements.treeSearchInput.focus();
        }

        // =========================================================================
        // Text Content Search
        // =========================================================================

        function setSearchMode(mode) {
            state.searchMode = mode;

            // Update toggle buttons
            elements.searchModeElements.classList.toggle('active', mode === 'elements');
            elements.searchModeText.classList.toggle('active', mode === 'text');

            // Update placeholder
            elements.treeSearchInput.placeholder = mode === 'elements' ?
                'Search elements...' : 'Search text content...';

            // Show/hide appropriate panel
            elements.elementTree.style.display = mode === 'elements' ? 'block' : 'none';
            elements.textSearchResults.style.display = mode === 'text' ? 'block' : 'none';

            // Clear and re-run search with current query
            const query = elements.treeSearchInput.value;
            if (mode === 'elements') {
                clearTextSearchResults();
                filterElementTree(query);
            } else {
                filterElementTree(''); // Reset element tree
                searchTextContent(query);
            }
        }

        function getTextSearchElementPath(element) {
            const path = [];
            let current = element;
            const doc = elements.previewFrame.contentDocument;
            const body = doc.body;

            while (current && current !== body && current.parentElement) {
                const parent = current.parentElement;
                const children = Array.from(parent.children);
                const index = children.indexOf(current);
                path.unshift(index);
                current = parent;
            }

            return path;
        }

        function searchTextContent(query) {
            const trimmedQuery = query.trim().toLowerCase();

            // Clear previous results
            clearTextSearchResults();

            if (!trimmedQuery) {
                elements.textSearchHint.style.display = 'block';
                elements.treeSearchCount.classList.remove('visible');
                elements.treeSearchWrapper.classList.remove('has-value');
                return;
            }

            elements.textSearchHint.style.display = 'none';
            elements.treeSearchWrapper.classList.add('has-value');

            const doc = elements.previewFrame.contentDocument;
            if (!doc || !doc.body) {
                elements.textSearchResults.innerHTML = '<div class="text-search-empty">No document loaded</div>';
                return;
            }

            // Find all text nodes
            const results = [];
            const walker = document.createTreeWalker(
                doc.body,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(node) {
                        // Skip empty/whitespace-only nodes
                        if (!node.textContent.trim()) return NodeFilter.FILTER_REJECT;
                        // Skip script/style content
                        if (node.parentElement.tagName === 'SCRIPT' ||
                            node.parentElement.tagName === 'STYLE') {
                            return NodeFilter.FILTER_REJECT;
                        }
                        return NodeFilter.FILTER_ACCEPT;
                    }
                }
            );

            let textNode;
            while (textNode = walker.nextNode()) {
                const text = textNode.textContent;
                const textLower = text.toLowerCase();

                if (textLower.includes(trimmedQuery)) {
                    const element = textNode.parentElement;
                    const path = getTextSearchElementPath(element);

                    // Find all match positions
                    let index = 0;
                    while ((index = textLower.indexOf(trimmedQuery, index)) !== -1) {
                        results.push({
                            element: element,
                            path: path,
                            text: text,
                            matchStart: index,
                            matchEnd: index + trimmedQuery.length,
                            tagName: element.tagName.toLowerCase()
                        });
                        index += trimmedQuery.length;
                    }
                }
            }

            state.textSearchResults = results;

            // Update count
            elements.treeSearchCount.textContent = results.length + ' match' + (results.length !== 1 ? 'es' : '');
            elements.treeSearchCount.classList.add('visible');

            // Render results
            if (results.length === 0) {
                elements.textSearchResults.innerHTML = '<div class="text-search-empty">No matches found</div>';
            } else {
                renderTextSearchResults(results, trimmedQuery);
            }
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function renderTextSearchResults(results, query) {
            // Group by element to avoid duplicates
            const uniqueResults = [];
            const seenPaths = new Set();

            results.forEach(result => {
                const pathKey = result.path.join(',');
                if (!seenPaths.has(pathKey)) {
                    seenPaths.add(pathKey);
                    uniqueResults.push(result);
                }
            });

            const html = uniqueResults.map((result, index) => {
                // Get context around the match
                const text = result.text.trim();
                const maxLength = 80;
                let displayText = text;

                if (text.length > maxLength) {
                    // Try to center around the first match
                    const matchIndex = text.toLowerCase().indexOf(query);
                    const start = Math.max(0, matchIndex - 30);
                    const end = Math.min(text.length, matchIndex + query.length + 30);
                    displayText = (start > 0 ? '...' : '') +
                        text.substring(start, end) +
                        (end < text.length ? '...' : '');
                }

                // Highlight all matches in the display text
                const highlightedText = displayText.replace(
                    new RegExp(escapeRegExp(query), 'gi'),
                    '<mark>$&</mark>'
                );

                return '<div class="text-search-result" data-index="' + index + '" data-path="' + result.path.join(',') + '">' +
                    '<div class="text-search-result-tag">&lt;' + result.tagName + '&gt;</div>' +
                    '<div class="text-search-result-text">' + highlightedText + '</div>' +
                '</div>';
            }).join('');

            elements.textSearchResults.innerHTML = html;

            // Add click handlers
            elements.textSearchResults.querySelectorAll('.text-search-result').forEach(resultEl => {
                resultEl.addEventListener('click', () => {
                    const path = resultEl.dataset.path.split(',').map(Number);
                    selectElementByPath(path, { scrollToElement: true });
                });
            });
        }

        function clearTextSearchResults() {
            state.textSearchResults = [];
            elements.textSearchResults.innerHTML = '<div class="text-search-hint" id="text-search-hint">Type to search text content (e.g., find typos)</div>';
            elements.textSearchHint = elements.textSearchResults.querySelector('#text-search-hint');
        }

        // =========================================================================
        // Selection
        // =========================================================================

        function setupFrameListeners(doc) {
            let hoveredElement = null;

            doc.body.addEventListener('mouseover', (e) => {
                if (state.isPanning) return;
                if (hoveredElement && hoveredElement !== state.selectedElement) {
                    hoveredElement.classList.remove('editor-hover');
                }
                if (e.target !== state.selectedElement && e.target !== doc.body) {
                    e.target.classList.add('editor-hover');
                    showAlignmentGuides(e.target);
                    hoveredElement = e.target;
                }
            });

            doc.body.addEventListener('mouseout', (e) => {
                if (e.target !== state.selectedElement) {
                    e.target.classList.remove('editor-hover');
                    clearGuides();
                }
            });

            doc.body.addEventListener('click', (e) => {
                if (state.isPanning) return;

                // In preview mode, allow normal click behavior
                if (state.previewMode) {
                    return; // Don't prevent default, let clicks work normally
                }

                e.preventDefault();
                e.stopPropagation();
                const path = getElementPath(e.target, doc.body);
                selectElementByPath(path, {
                    addToSelection: e.shiftKey,
                    toggleSelection: e.ctrlKey || e.metaKey
                });
            });

            doc.body.addEventListener('dblclick', (e) => {
                if (state.isPanning) return;
                if (state.previewMode) return; // Allow normal dblclick in preview
                e.preventDefault();
                if (isTextElement(e.target)) {
                    enableInlineEdit(e.target);
                }
            });

            // Context menu on right-click
            doc.body.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();

                // Select the element if not already selected
                const path = getElementPath(e.target, doc.body);
                if (!state.selectedElements.includes(e.target)) {
                    selectElementByPath(path);
                }

                // Get position relative to main window
                const frameRect = elements.previewFrame.getBoundingClientRect();
                const x = frameRect.left + e.clientX * state.zoom + state.panX;
                const y = frameRect.top + e.clientY * state.zoom + state.panY;

                showContextMenu(e.clientX + frameRect.left, e.clientY + frameRect.top, e.target);
            });
        }

        function getElementPath(element, root) {
            const path = [];
            let current = element;

            while (current && current !== root) {
                const parent = current.parentElement;
                if (parent) {
                    const index = Array.from(parent.children).indexOf(current);
                    path.unshift(index);
                }
                current = parent;
            }

            return path;
        }

        function getElementByPath(path) {
            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;

            let element = doc.body;
            for (const index of path) {
                if (element.children[index]) {
                    element = element.children[index];
                } else {
                    return null;
                }
            }
            return element;
        }

        // Scroll canvas to center element in view
        function scrollCanvasToElement(element) {
            if (!element || !elements.previewFrame || !elements.canvasWrapper) return;

            try {
                // Get absolute position within iframe document using offsetLeft/offsetTop
                // This gives correct coordinates regardless of scroll/pan state
                let offsetX = 0, offsetY = 0;
                let el = element;
                while (el) {
                    offsetX += el.offsetLeft;
                    offsetY += el.offsetTop;
                    el = el.offsetParent;
                }

                // Calculate element center in iframe document coordinates
                const elementCenterX = offsetX + element.offsetWidth / 2;
                const elementCenterY = offsetY + element.offsetHeight / 2;

                // Get canvas viewport dimensions
                const canvasRect = elements.canvasWrapper.getBoundingClientRect();
                const viewportWidth = canvasRect.width;
                const viewportHeight = canvasRect.height;

                // Calculate the pan needed to center this element in the viewport
                // Formula: pan = viewport_center - (element_center * zoom)
                state.panX = (viewportWidth / 2) - (elementCenterX * state.zoom);
                state.panY = (viewportHeight / 2) - (elementCenterY * state.zoom);
                updateTransform();
            } catch (e) {
                // Silently fail if element is not accessible
            }
        }

        function selectElementByPath(path, options = {}) {
            const { addToSelection = false, toggleSelection = false, scrollToElement = false } = options;
            const pathStr = path.join(',');

            // Check if already selected
            const existingIndex = state.selectedPaths.findIndex(p => p.join(',') === pathStr);
            const isAlreadySelected = existingIndex !== -1;

            if (toggleSelection && isAlreadySelected) {
                // Remove from selection
                removeFromSelection(existingIndex);
                return;
            }

            if (!addToSelection && !toggleSelection) {
                // Clear existing selection
                clearAllSelectionHighlights();
                state.selectedElements = [];
                state.selectedPaths = [];
            }

            if (isAlreadySelected && (addToSelection || toggleSelection)) {
                // Already selected, don't add again
                return;
            }

            const element = getElementByPath(path);
            if (element) {
                // Add to selection
                element.classList.add('editor-selected');
                state.selectedElements.push(element);
                state.selectedPaths.push(path);

                // Update primary selection (last selected)
                state.selectedElement = element;
                state.selectedPath = path;

                // Highlight tree node
                const treeNode = document.querySelector('.tree-node[data-path="' + pathStr + '"]');
                if (treeNode) {
                    treeNode.classList.add('selected');
                    treeNode.scrollIntoView({ block: 'nearest' });
                }

                // Scroll canvas to show element (when clicking from tree)
                if (scrollToElement) {
                    scrollCanvasToElement(element);
                }

                showProperties(element);
            }
        }

        function removeFromSelection(index) {
            const element = state.selectedElements[index];
            const path = state.selectedPaths[index];

            if (element) {
                element.classList.remove('editor-selected');
            }

            // Remove from tree
            const treeNode = document.querySelector('.tree-node[data-path="' + path.join(',') + '"]');
            if (treeNode) {
                treeNode.classList.remove('selected');
            }

            // Remove from arrays
            state.selectedElements.splice(index, 1);
            state.selectedPaths.splice(index, 1);

            // Update primary selection
            if (state.selectedElements.length > 0) {
                state.selectedElement = state.selectedElements[state.selectedElements.length - 1];
                state.selectedPath = state.selectedPaths[state.selectedPaths.length - 1];
                showProperties(state.selectedElement);
            } else {
                state.selectedElement = null;
                state.selectedPath = null;
                elements.noSelection.style.display = 'block';
                elements.propertySections.style.display = 'none';
            }
        }

        function clearAllSelectionHighlights() {
            state.selectedElements.forEach(el => {
                if (el) el.classList.remove('editor-selected');
            });
            document.querySelectorAll('.tree-node.selected').forEach(n => n.classList.remove('selected'));
        }

        function clearSelection() {
            clearAllSelectionHighlights();
            state.selectedElement = null;
            state.selectedPath = null;
            state.selectedElements = [];
            state.selectedPaths = [];

            elements.noSelection.style.display = 'block';
            elements.propertySections.style.display = 'none';

            // Hide resize overlay
            elements.resizeOverlay.classList.remove('active');

            // Hide spacing overlay
            elements.spacingOverlay.classList.remove('active');

            // Hide quick actions
            hideQuickActions();
        }

        // =========================================================================
        // Delete Element
        // =========================================================================

        function deleteSelectedElement() {
            if (state.selectedElements.length === 0) return false;

            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;

            // Filter out elements that can't be deleted
            const deletableElements = state.selectedElements.filter(element => {
                const tag = element.tagName.toUpperCase();
                if (tag === 'BODY' || tag === 'HTML' || tag === 'HEAD') {
                    return false;
                }
                return true;
            });

            if (deletableElements.length === 0) return false;

            // Check if deleting would leave body empty
            const bodyChildren = Array.from(doc.body.children);
            const remainingChildren = bodyChildren.filter(child =>
                !deletableElements.includes(child)
            );
            if (remainingChildren.length === 0) {
                // Can't delete all children of body
                return false;
            }

            // Save state for undo
            saveState('delete');

            // Remove all deletable elements
            deletableElements.forEach(element => {
                if (element.parentElement) {
                    element.parentElement.removeChild(element);
                }
            });

            // Clear selection and rebuild tree
            clearSelection();
            buildElementTree(doc.body);

            return true;
        }

        // =========================================================================
        // Copy/Paste/Duplicate
        // =========================================================================

        function copySelectedElements() {
            if (state.selectedElements.length === 0) return false;

            // Clone all selected elements (without editor classes)
            state.clipboard = state.selectedElements.map(el => {
                const clone = el.cloneNode(true);
                clone.classList.remove('editor-selected', 'editor-hover');
                return clone.outerHTML;
            });

            return true;
        }

        function duplicateSelectedElement() {
            if (state.selectedElements.length === 0) return false;

            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;

            // Filter out elements that can't be duplicated
            const duplicatableElements = state.selectedElements.filter(element => {
                const tag = element.tagName.toUpperCase();
                if (tag === 'BODY' || tag === 'HTML' || tag === 'HEAD') {
                    return false;
                }
                return true;
            });

            if (duplicatableElements.length === 0) return false;

            // Save state for undo
            saveState('duplicate');

            // Duplicate each element right after its original
            const newElements = [];
            duplicatableElements.forEach(element => {
                const clone = element.cloneNode(true);
                clone.classList.remove('editor-selected', 'editor-hover');
                element.parentElement.insertBefore(clone, element.nextSibling);
                newElements.push(clone);
            });

            // Update tree and select the new elements
            buildElementTree(doc.body);

            // Clear current selection and select the duplicated elements
            clearAllSelectionHighlights();
            state.selectedElements = [];
            state.selectedPaths = [];

            newElements.forEach((el) => {
                const path = getElementPath(el, doc.body);
                el.classList.add('editor-selected');
                state.selectedElements.push(el);
                state.selectedPaths.push(path);

                const treeNode = document.querySelector('.tree-node[data-path="' + path.join(',') + '"]');
                if (treeNode) {
                    treeNode.classList.add('selected');
                }
            });

            // Update primary selection
            if (newElements.length > 0) {
                state.selectedElement = newElements[newElements.length - 1];
                state.selectedPath = state.selectedPaths[state.selectedPaths.length - 1];
                showProperties(state.selectedElement);
            }

            return true;
        }

        function nudgeSelectedElements(dx, dy) {
            if (state.selectedElements.length === 0) return false;

            // Save state for undo
            saveState('move');

            state.selectedElements.forEach(element => {
                const style = element.style;
                const computedStyle = element.ownerDocument.defaultView.getComputedStyle(element);

                // Get current position or margins
                let currentLeft = parseInt(style.marginLeft) || parseInt(computedStyle.marginLeft) || 0;
                let currentTop = parseInt(style.marginTop) || parseInt(computedStyle.marginTop) || 0;

                // Apply nudge to margins
                element.style.marginLeft = (currentLeft + dx) + 'px';
                element.style.marginTop = (currentTop + dy) + 'px';
            });

            // Update property panel if single selection
            if (state.selectedElement) {
                showProperties(state.selectedElement);
            }

            return true;
        }

        function pasteElements() {
            if (state.clipboard.length === 0) return false;
            if (!state.selectedElement) return false;

            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;

            // Save state for undo
            saveState('paste');

            // Paste as children of the currently selected element
            const target = state.selectedElement;

            state.clipboard.forEach(html => {
                const temp = doc.createElement('div');
                temp.innerHTML = html;
                const newElement = temp.firstElementChild;
                if (newElement) {
                    target.appendChild(newElement);
                }
            });

            // Rebuild tree
            buildElementTree(doc.body);

            return true;
        }

        // =========================================================================
        // Inline Editing
        // =========================================================================

        function isTextElement(el) {
            const textTags = ['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'SPAN', 'A', 'BUTTON', 'LI', 'TD', 'TH', 'LABEL'];
            return textTags.includes(el.tagName);
        }

        function enableInlineEdit(element) {
            const originalText = element.textContent;
            element.contentEditable = true;
            element.focus();

            const range = document.createRange();
            range.selectNodeContents(element);
            const sel = element.ownerDocument.defaultView.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);

            const finishEdit = () => {
                element.contentEditable = false;
                if (element.textContent !== originalText) {
                    saveState('text');
                    if (state.selectedElement === element) {
                        elements.propText.value = element.textContent;
                    }
                }
            };

            element.addEventListener('blur', finishEdit, { once: true });
            element.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    element.blur();
                }
                if (e.key === 'Escape') {
                    element.textContent = originalText;
                    element.blur();
                }
            });
        }

        // =========================================================================
        // Property Panel
        // =========================================================================

        function showProperties(element) {
            elements.noSelection.style.display = 'none';
            elements.propertySections.style.display = 'block';

            const computed = element.ownerDocument.defaultView.getComputedStyle(element);

            elements.propTag.value = element.tagName.toLowerCase();

            if (isTextElement(element)) {
                elements.textContentRow.style.display = 'flex';
                elements.propText.value = element.textContent;
            } else {
                elements.textContentRow.style.display = 'none';
            }

            // Set font size dropdown - match preset or show custom
            const fontSize = computed.fontSize;
            const fontSizePresets = ['12px', '14px', '16px', '18px', '24px', '32px', '48px'];
            if (fontSizePresets.includes(fontSize)) {
                elements.propFontSize.value = fontSize;
            } else {
                // Add custom option with actual value if not already there
                let customOption = elements.propFontSize.querySelector('option[value="custom"]');
                if (customOption) {
                    customOption.textContent = 'Custom (' + fontSize + ')';
                }
                elements.propFontSize.value = 'custom';
            }
            elements.propFontWeight.value = computed.fontWeight;

            // Update font picker preview
            const fontFamily = extractPrimaryFont(computed.fontFamily);
            updateFontPickerPreview(fontFamily);
            updateFontStyleButtons();
            const textColor = rgbToHex(computed.color);
            elements.propColor.value = textColor !== 'transparent' ? textColor : '#000000';
            elements.propColorValue.textContent = textColor;
            elements.propTextAlign.value = computed.textAlign;

            // Track color for "apply to all matching" feature
            state.lastTextColor = textColor !== 'transparent' ? textColor : null;

            const bgColor = rgbToHex(computed.backgroundColor);
            // Color input doesn't support 'transparent', use white as fallback for display
            elements.propBgColor.value = bgColor !== 'transparent' ? bgColor : '#ffffff';
            elements.propBgColorValue.textContent = bgColor !== 'transparent' ? bgColor : 'transparent';

            // Track background color for "apply to all matching" feature
            state.lastBgColor = bgColor !== 'transparent' ? bgColor : null;

            // Reset "apply to all" checkboxes when selecting new element
            if (elements.applyAllTextColor) elements.applyAllTextColor.checked = false;
            if (elements.applyAllBgColor) elements.applyAllBgColor.checked = false;

            // Update active color swatches
            updateActiveColorSwatch(textColor, 'text');
            updateActiveColorSwatch(bgColor !== 'transparent' ? bgColor : '#ffffff', 'bg');

            elements.propMarginTop.value = computed.marginTop;
            elements.propMarginRight.value = computed.marginRight;
            elements.propMarginBottom.value = computed.marginBottom;
            elements.propMarginLeft.value = computed.marginLeft;

            elements.propPaddingTop.value = computed.paddingTop;
            elements.propPaddingRight.value = computed.paddingRight;
            elements.propPaddingBottom.value = computed.paddingBottom;
            elements.propPaddingLeft.value = computed.paddingLeft;

            elements.propWidth.value = element.style.width || 'auto';
            elements.propHeight.value = element.style.height || 'auto';

            // Update resize overlay
            updateResizeOverlay();

            // Update spacing overlay
            updateSpacingOverlay();

            // Update quick actions toolbar
            updateQuickActions();
        }

        function rgbToHex(rgb) {
            // Handle null, undefined, or empty values
            if (!rgb || typeof rgb !== 'string') return '#000000';

            // Already hex
            if (rgb.startsWith('#')) return rgb.toLowerCase();

            // Handle transparent
            if (rgb === 'transparent' || rgb === 'rgba(0, 0, 0, 0)') return 'transparent';

            // Parse rgb/rgba
            const match = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)/);
            if (!match) return '#000000';

            const r = parseInt(match[1]).toString(16).padStart(2, '0');
            const g = parseInt(match[2]).toString(16).padStart(2, '0');
            const b = parseInt(match[3]).toString(16).padStart(2, '0');

            return '#' + r + g + b;
        }

        // =========================================================================
        // Document Colors System
        // =========================================================================

        function scanDocumentColors() {
            if (!state.documentLoaded) return;

            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;
            if (!doc.body) return;

            const colorMap = new Map(); // color -> { count, elements, properties }
            const allElements = doc.body.querySelectorAll('*:not(script):not(style):not(#editor-styles)');

            allElements.forEach(el => {
                const computed = doc.defaultView.getComputedStyle(el);

                // Scan text color
                const textColor = rgbToHex(computed.color);
                if (textColor && textColor !== '#000000') { // Skip pure black as it's often default
                    addColorToMap(colorMap, textColor, el, 'color');
                }

                // Scan background color
                const bgColor = rgbToHex(computed.backgroundColor);
                if (bgColor && bgColor !== '#ffffff' && bgColor !== '#000000' && computed.backgroundColor !== 'rgba(0, 0, 0, 0)') {
                    addColorToMap(colorMap, bgColor, el, 'backgroundColor');
                }

                // Scan inline style colors (higher priority as user likely set these)
                if (el.style.color) {
                    const inlineColor = rgbToHex(el.style.color);
                    if (inlineColor) addColorToMap(colorMap, inlineColor, el, 'color');
                }
                if (el.style.backgroundColor) {
                    const inlineBgColor = rgbToHex(el.style.backgroundColor);
                    if (inlineBgColor) addColorToMap(colorMap, inlineBgColor, el, 'backgroundColor');
                }

                // Scan border colors
                const borderColor = rgbToHex(computed.borderColor);
                if (borderColor && borderColor !== '#000000' && computed.borderWidth !== '0px') {
                    addColorToMap(colorMap, borderColor, el, 'borderColor');
                }
            });

            // Convert map to sorted array (most used first)
            state.documentColors = Array.from(colorMap.entries())
                .map(([color, data]) => ({
                    color,
                    count: data.count,
                    elements: data.elements,
                    properties: data.properties
                }))
                .sort((a, b) => b.count - a.count);

            // Update UI
            renderDocumentColors();
        }

        function addColorToMap(map, color, element, property) {
            if (!map.has(color)) {
                map.set(color, { count: 0, elements: [], properties: new Set() });
            }
            const data = map.get(color);
            data.count++;
            if (!data.elements.includes(element)) {
                data.elements.push(element);
            }
            data.properties.add(property);
        }

        function renderDocumentColors() {
            const textGrid = elements.docColorsTextGrid;
            const bgGrid = elements.docColorsBgGrid;

            // Clear existing
            textGrid.innerHTML = '';
            bgGrid.innerHTML = '';

            if (state.documentColors.length === 0) {
                textGrid.innerHTML = '<span class="no-document-colors">No colors found</span>';
                bgGrid.innerHTML = '<span class="no-document-colors">No colors found</span>';
                elements.btnReplaceTextColor.disabled = true;
                elements.btnReplaceBgColor.disabled = true;
                return;
            }

            // Render color swatches (limit to 12 per grid)
            const maxColors = 12;
            state.documentColors.slice(0, maxColors).forEach(colorData => {
                // Text color swatch
                const textSwatch = createColorSwatch(colorData, 'text');
                textGrid.appendChild(textSwatch);

                // Background color swatch
                const bgSwatch = createColorSwatch(colorData, 'bg');
                bgGrid.appendChild(bgSwatch);
            });
        }

        function createColorSwatch(colorData, type) {
            const swatch = document.createElement('div');
            swatch.className = 'doc-color-swatch';
            swatch.style.backgroundColor = colorData.color;
            swatch.title = `${colorData.color} (${colorData.count} uses)`;
            swatch.dataset.color = colorData.color;
            swatch.dataset.type = type;

            // Add count badge for colors used more than once
            if (colorData.count > 1) {
                const countBadge = document.createElement('span');
                countBadge.className = 'doc-color-swatch-count';
                countBadge.textContent = colorData.count > 99 ? '99+' : colorData.count;
                swatch.appendChild(countBadge);
            }

            // Click to apply color
            swatch.addEventListener('click', (e) => {
                e.stopPropagation();
                applyDocumentColor(colorData.color, type);
            });

            // Right-click to select for replace
            swatch.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                selectColorForReplace(colorData.color, type);
            });

            return swatch;
        }

        function applyDocumentColor(color, type) {
            if (!state.selectedElement) {
                showToast('info', 'Select an element', 'Click on an element to apply this color');
                return;
            }

            saveState('style');

            if (type === 'text') {
                state.selectedElement.style.color = color;
                elements.propColor.value = color;
                elements.propColorValue.textContent = color;
            } else {
                state.selectedElement.style.backgroundColor = color;
                elements.propBgColor.value = color;
                elements.propBgColorValue.textContent = color;
            }

            // Update swatches to show active state
            updateActiveColorSwatch(color, type);
            showToast('success', 'Color applied', `Applied ${color}`);
        }

        function updateActiveColorSwatch(color, type) {
            const grid = type === 'text' ? elements.docColorsTextGrid : elements.docColorsBgGrid;
            grid.querySelectorAll('.doc-color-swatch').forEach(swatch => {
                swatch.classList.toggle('active', swatch.dataset.color === color);
            });
        }

        function selectColorForReplace(color, type) {
            state.replaceColorType = type;
            state.replaceFromColor = color;
            state.selectedDocColor = color;

            // Update active state visually
            updateActiveColorSwatch(color, type);

            // Enable the replace button
            if (type === 'text') {
                elements.btnReplaceTextColor.disabled = false;
            } else {
                elements.btnReplaceBgColor.disabled = false;
            }

            showToast('info', 'Color selected', `Right-clicked ${color}. Click "Replace all..." to change it.`);
        }

        function openReplaceModal(type) {
            // Find the current color (use selected or first in list)
            let fromColor = state.selectedDocColor;
            if (!fromColor && state.documentColors.length > 0) {
                fromColor = state.documentColors[0].color;
            }
            if (!fromColor) {
                showToast('warning', 'No color selected', 'Select a color first');
                return;
            }

            state.replaceColorType = type;
            state.replaceFromColor = fromColor;

            // Find color data
            const colorData = state.documentColors.find(c => c.color === fromColor);
            const count = colorData ? colorData.count : 0;

            // Update modal UI
            elements.replaceFromSwatch.style.backgroundColor = fromColor;
            elements.replaceToSwatch.style.backgroundColor = fromColor;
            elements.replaceNewColor.value = fromColor;
            elements.replaceNewColorValue.textContent = fromColor;
            elements.replaceCount.textContent = count;
            elements.replaceInfo.innerHTML = `Found <strong>${count}</strong> element${count !== 1 ? 's' : ''} using this color`;

            // Show modal
            elements.colorReplaceModal.classList.add('visible');
        }

        function closeReplaceModal() {
            elements.colorReplaceModal.classList.remove('visible');
            state.selectedDocColor = null;
        }

        function updateReplacePreview() {
            const newColor = elements.replaceNewColor.value;
            elements.replaceToSwatch.style.backgroundColor = newColor;
            elements.replaceNewColorValue.textContent = newColor;
        }

        function executeColorReplace() {
            const fromColor = state.replaceFromColor;
            const toColor = elements.replaceNewColor.value;
            const type = state.replaceColorType;

            if (!fromColor || !toColor) return;

            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;
            if (!doc.body) return;

            saveState('style');

            let replacedCount = 0;
            const allElements = doc.body.querySelectorAll('*:not(script):not(style)');

            allElements.forEach(el => {
                const computed = doc.defaultView.getComputedStyle(el);

                // Replace text colors
                if (type === 'text') {
                    const currentColor = rgbToHex(computed.color);
                    if (currentColor === fromColor) {
                        el.style.color = toColor;
                        replacedCount++;
                    }
                }

                // Replace background colors
                if (type === 'bg') {
                    const currentBgColor = rgbToHex(computed.backgroundColor);
                    if (currentBgColor === fromColor) {
                        el.style.backgroundColor = toColor;
                        replacedCount++;
                    }
                }
            });

            closeReplaceModal();
            scanDocumentColors();

            // Update property panel if element is selected
            if (state.selectedElement) {
                showProperties(state.selectedElement);
            }

            showToast('success', 'Colors replaced', `Changed ${replacedCount} element${replacedCount !== 1 ? 's' : ''} from ${fromColor} to ${toColor}`);
        }

        function applyColorToAllMatching(fromColor, toColor, property) {
            // Apply color change to all elements with matching color
            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;
            if (!doc.body) return;

            saveState('style');

            let changedCount = 0;
            const allElements = doc.body.querySelectorAll('*:not(script):not(style):not(#editor-styles)');

            allElements.forEach(el => {
                const computed = doc.defaultView.getComputedStyle(el);
                const currentColor = rgbToHex(computed[property]);

                if (currentColor === fromColor) {
                    el.style[property] = toColor;
                    changedCount++;
                }
            });

            // Update state to track new color
            if (property === 'color') {
                state.lastTextColor = toColor;
            } else if (property === 'backgroundColor') {
                state.lastBgColor = toColor;
            }

            // Refresh document colors
            scanDocumentColors();

            if (changedCount > 1) {
                showToast('success', 'Colors updated', `Changed ${changedCount} elements from ${fromColor} to ${toColor}`);
            }
        }

        function updateColorValueDisplay() {
            // Update the color value displays when color inputs change
            elements.propColorValue.textContent = elements.propColor.value;
            elements.propBgColorValue.textContent = elements.propBgColor.value;
        }

        // Copy color to clipboard when clicking value display
        function copyColorToClipboard(colorValue) {
            navigator.clipboard.writeText(colorValue).then(() => {
                showToast('success', 'Copied', `${colorValue} copied to clipboard`);
            }).catch(() => {
                showToast('error', 'Copy failed', 'Could not copy to clipboard');
            });
        }

        // =========================================================================
        // Document Fonts System
        // =========================================================================

        const WEB_SAFE_FONTS = [
            'Arial', 'Helvetica', 'Times New Roman', 'Georgia', 'Verdana',
            'Trebuchet MS', 'Courier New', 'Lucida Console', 'Tahoma', 'Impact'
        ];

        const GOOGLE_FONTS = [
            'Inter', 'Roboto', 'Open Sans', 'Lato', 'Montserrat', 'Poppins',
            'Raleway', 'Source Sans Pro', 'Nunito', 'Ubuntu', 'Playfair Display',
            'Merriweather', 'PT Sans', 'Oswald', 'Rubik', 'Work Sans', 'Fira Sans',
            'Quicksand', 'Karla', 'Josefin Sans', 'DM Sans', 'Manrope', 'Space Grotesk'
        ];

        function scanDocumentFonts() {
            if (!state.documentLoaded) return;

            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;
            if (!doc.body) return;

            const fontMap = new Map();
            const allElements = doc.body.querySelectorAll('*:not(script):not(style):not(#editor-styles)');

            allElements.forEach(el => {
                const computed = doc.defaultView.getComputedStyle(el);
                const fontFamily = computed.fontFamily;

                if (fontFamily) {
                    const primaryFont = extractPrimaryFont(fontFamily);
                    if (primaryFont) {
                        if (!fontMap.has(primaryFont)) {
                            fontMap.set(primaryFont, { count: 0, elements: [], fullStack: fontFamily });
                        }
                        const data = fontMap.get(primaryFont);
                        data.count++;
                        if (data.elements.length < 10) {
                            data.elements.push(el);
                        }
                    }
                }
            });

            state.documentFonts = Array.from(fontMap.entries())
                .map(([font, data]) => ({
                    font,
                    count: data.count,
                    elements: data.elements,
                    fullStack: data.fullStack
                }))
                .sort((a, b) => b.count - a.count);

            renderFontPicker();
        }

        function extractPrimaryFont(fontStack) {
            const fonts = fontStack.split(',').map(f => f.trim().replace(/["']/g, ''));
            return fonts[0] || null;
        }

        function renderFontPicker(filter = '') {
            const list = elements.fontPickerList;
            list.innerHTML = '';

            const filterLower = filter.toLowerCase();

            // Recent fonts section
            if (state.recentFonts.length > 0 && !filter) {
                const recentSection = document.createElement('div');
                recentSection.className = 'font-picker-section';
                recentSection.innerHTML = '<div class="font-picker-section-title">Recent</div>';

                state.recentFonts.slice(0, 5).forEach(font => {
                    const item = createFontItem(font, null);
                    recentSection.appendChild(item);
                });

                list.appendChild(recentSection);
            }

            // Document fonts section
            const docFonts = filter
                ? state.documentFonts.filter(f => f.font.toLowerCase().includes(filterLower))
                : state.documentFonts;

            if (docFonts.length > 0) {
                const docSection = document.createElement('div');
                docSection.className = 'font-picker-section';
                docSection.innerHTML = '<div class="font-picker-section-title">Document Fonts</div>';

                docFonts.forEach(fontData => {
                    const item = createFontItem(fontData.font, fontData.count, fontData.elements);
                    docSection.appendChild(item);
                });

                list.appendChild(docSection);
            }

            // Web-safe fonts section
            const webSafe = filter
                ? WEB_SAFE_FONTS.filter(f => f.toLowerCase().includes(filterLower))
                : WEB_SAFE_FONTS;

            if (webSafe.length > 0) {
                const webSection = document.createElement('div');
                webSection.className = 'font-picker-section';
                webSection.innerHTML = '<div class="font-picker-section-title">Web Safe</div>';

                webSafe.forEach(font => {
                    const item = createFontItem(font, null);
                    webSection.appendChild(item);
                });

                list.appendChild(webSection);
            }

            // Google fonts section
            const googleFonts = filter
                ? GOOGLE_FONTS.filter(f => f.toLowerCase().includes(filterLower))
                : GOOGLE_FONTS;

            if (googleFonts.length > 0) {
                const googleSection = document.createElement('div');
                googleSection.className = 'font-picker-section';
                googleSection.innerHTML = '<div class="font-picker-section-title">Google Fonts</div>';

                googleFonts.forEach(font => {
                    const item = createFontItem(font, null, null, true);
                    googleSection.appendChild(item);
                });

                list.appendChild(googleSection);
            }

            if (list.children.length === 0) {
                list.innerHTML = '<div class="font-picker-no-results">No fonts found</div>';
            }
        }

        function createFontItem(font, count, elementsArray, isGoogleFont = false) {
            const item = document.createElement('div');
            item.className = 'font-picker-item';
            item.dataset.font = font;

            if (elementsArray && elementsArray.length > 0) {
                item.dataset.hasElements = 'true';
            }

            const name = document.createElement('span');
            name.className = 'font-picker-item-name';
            name.textContent = font;
            name.style.fontFamily = '"' + font + '", sans-serif';
            item.appendChild(name);

            if (count !== null) {
                const countBadge = document.createElement('span');
                countBadge.className = 'font-picker-item-count';
                countBadge.textContent = count;
                item.appendChild(countBadge);
            }

            if (elementsArray && elementsArray.length > 0) {
                item.addEventListener('mouseenter', () => {
                    elementsArray.forEach(el => {
                        el.style.outline = '2px solid #8b5cf6';
                        el.style.outlineOffset = '2px';
                    });
                });

                item.addEventListener('mouseleave', () => {
                    elementsArray.forEach(el => {
                        el.style.outline = '';
                        el.style.outlineOffset = '';
                    });
                });
            }

            item.addEventListener('click', () => {
                selectFont(font, isGoogleFont);
            });

            return item;
        }

        function selectFont(font, isGoogleFont = false) {
            if (!state.selectedElement) return;

            if (isGoogleFont) {
                loadGoogleFont(font);
            }

            saveState('style');
            state.selectedElement.style.fontFamily = '"' + font + '", sans-serif';

            addToRecentFonts(font);
            updateFontPickerPreview(font);
            closeFontPicker();
            showProperties(state.selectedElement);

            showToast('success', 'Font Applied', 'Changed font to ' + font);
        }

        function loadGoogleFont(fontName) {
            const frame = elements.previewFrame;
            const doc = frame.contentDocument || frame.contentWindow.document;

            const fontId = 'google-font-' + fontName.replace(/\s+/g, '-').toLowerCase();
            if (doc.getElementById(fontId)) return;

            const link = doc.createElement('link');
            link.id = fontId;
            link.rel = 'stylesheet';
            link.href = 'https://fonts.googleapis.com/css2?family=' + encodeURIComponent(fontName) + ':wght@400;500;600;700&display=swap';
            doc.head.appendChild(link);
        }

        function addToRecentFonts(font) {
            const index = state.recentFonts.indexOf(font);
            if (index > -1) {
                state.recentFonts.splice(index, 1);
            }

            state.recentFonts.unshift(font);

            if (state.recentFonts.length > 10) {
                state.recentFonts = state.recentFonts.slice(0, 10);
            }

            localStorage.setItem('mangle-recent-fonts', JSON.stringify(state.recentFonts));
        }

        function updateFontPickerPreview(font) {
            if (font) {
                elements.fontPickerPreview.textContent = font;
                elements.fontPickerPreview.style.fontFamily = '"' + font + '", sans-serif';
            } else {
                elements.fontPickerPreview.textContent = 'Select font...';
                elements.fontPickerPreview.style.fontFamily = '';
            }
        }

        function openFontPicker() {
            state.fontPickerOpen = true;
            elements.fontPickerTrigger.classList.add('open');
            elements.fontPickerDropdown.classList.add('open');
            elements.fontPickerSearch.value = '';
            elements.fontPickerSearch.focus();
            renderFontPicker();
        }

        function closeFontPicker() {
            state.fontPickerOpen = false;
            elements.fontPickerTrigger.classList.remove('open');
            elements.fontPickerDropdown.classList.remove('open');
        }

        function toggleFontPicker() {
            if (state.fontPickerOpen) {
                closeFontPicker();
            } else {
                openFontPicker();
            }
        }

        function toggleFontStyle(style) {
            if (!state.selectedElement) return;

            saveState('style');

            const computed = state.selectedElement.ownerDocument.defaultView.getComputedStyle(state.selectedElement);

            if (style === 'bold') {
                const currentWeight = parseInt(computed.fontWeight) || 400;
                const isBold = currentWeight >= 600;
                state.selectedElement.style.fontWeight = isBold ? 'normal' : 'bold';
                elements.fontStyleBold.classList.toggle('active', !isBold);
            } else if (style === 'italic') {
                const isItalic = computed.fontStyle === 'italic';
                state.selectedElement.style.fontStyle = isItalic ? 'normal' : 'italic';
                elements.fontStyleItalic.classList.toggle('active', !isItalic);
            }

            showProperties(state.selectedElement);
        }

        function updateFontStyleButtons() {
            if (!state.selectedElement) return;

            const computed = state.selectedElement.ownerDocument.defaultView.getComputedStyle(state.selectedElement);

            const weight = parseInt(computed.fontWeight) || 400;
            elements.fontStyleBold.classList.toggle('active', weight >= 600);
            elements.fontStyleItalic.classList.toggle('active', computed.fontStyle === 'italic');
        }

        // =========================================================================
        // Style Copy/Paste
        // =========================================================================

        const STYLE_PROPERTIES = {
            all: [
                'color', 'backgroundColor', 'fontFamily', 'fontSize', 'fontWeight', 'fontStyle',
                'textAlign', 'textDecoration', 'lineHeight', 'letterSpacing',
                'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft',
                'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft',
                'border', 'borderRadius', 'boxShadow', 'opacity', 'transform'
            ],
            colors: ['color', 'backgroundColor', 'borderColor'],
            typography: ['fontFamily', 'fontSize', 'fontWeight', 'fontStyle', 'textAlign', 'textDecoration', 'lineHeight', 'letterSpacing'],
            spacing: ['margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft']
        };

        function copyElementStyle(element, category = 'all') {
            if (!element) return null;

            const computed = element.ownerDocument.defaultView.getComputedStyle(element);
            const properties = STYLE_PROPERTIES[category] || STYLE_PROPERTIES.all;
            const styles = {};

            properties.forEach(prop => {
                const value = computed[prop];
                if (value && value !== 'none' && value !== 'normal' && value !== '0px' && value !== 'rgba(0, 0, 0, 0)') {
                    styles[prop] = value;
                }
            });

            return {
                styles,
                category,
                sourceTag: element.tagName.toLowerCase(),
                timestamp: Date.now()
            };
        }

        function pasteElementStyle(element, styleData) {
            if (!element || !styleData || !styleData.styles) return false;

            saveState('style');

            Object.entries(styleData.styles).forEach(([prop, value]) => {
                element.style[prop] = value;
            });

            return true;
        }

        function copyStyle() {
            if (!state.selectedElement) {
                showToast('warning', 'No selection', 'Select an element first');
                return;
            }

            state.styleClipboard = copyElementStyle(state.selectedElement);
            showStyleClipboardIndicator();
            showToast('success', 'Style copied', 'Click another element to apply this style');
        }

        function pasteStyle() {
            if (!state.selectedElement) {
                showToast('warning', 'No selection', 'Select an element first');
                return;
            }

            if (!state.styleClipboard) {
                showToast('warning', 'No style', 'Right-click an element and choose "Copy Style" first');
                return;
            }

            if (pasteElementStyle(state.selectedElement, state.styleClipboard)) {
                showToast('success', 'Style pasted', 'Applied ' + Object.keys(state.styleClipboard.styles).length + ' properties');
                showProperties(state.selectedElement);
            }
        }

        function clearStyleClipboard() {
            state.styleClipboard = null;
            state.eyedropperMode = false;
            hideStyleClipboardIndicator();
            elements.canvasArea.classList.remove('eyedropper-mode');
        }

        function showStyleClipboardIndicator() {
            elements.styleClipboardIndicator.classList.add('visible');
        }

        function hideStyleClipboardIndicator() {
            elements.styleClipboardIndicator.classList.remove('visible');
        }

        function toggleEyedropperMode() {
            state.eyedropperMode = !state.eyedropperMode;
            elements.canvasArea.classList.toggle('eyedropper-mode', state.eyedropperMode);

            if (state.eyedropperMode) {
                showToast('info', 'Eyedropper mode', 'Alt+click any element to sample its style');
            }
        }

        function showStylePreview(element, x, y) {
            if (!state.styleClipboard || !element) {
                hideStylePreview();
                return;
            }

            const previewContent = elements.stylePreviewContent;
            previewContent.innerHTML = '';

            const styles = state.styleClipboard.styles;
            const keys = Object.keys(styles).slice(0, 5); // Show max 5 properties

            keys.forEach(prop => {
                const item = document.createElement('div');
                item.className = 'style-preview-item';
                item.innerHTML = '<span class="style-preview-prop">' + prop + '</span><span class="style-preview-value">' + (styles[prop].length > 15 ? styles[prop].substring(0, 15) + '...' : styles[prop]) + '</span>';
                previewContent.appendChild(item);
            });

            if (Object.keys(styles).length > 5) {
                const more = document.createElement('div');
                more.className = 'style-preview-item';
                more.innerHTML = '<span class="style-preview-prop">...</span><span class="style-preview-value">+' + (Object.keys(styles).length - 5) + ' more</span>';
                previewContent.appendChild(more);
            }

            elements.stylePreviewOverlay.style.left = (x + 15) + 'px';
            elements.stylePreviewOverlay.style.top = (y + 15) + 'px';
            elements.stylePreviewOverlay.classList.add('visible');
        }

        function hideStylePreview() {
            elements.stylePreviewOverlay.classList.remove('visible');
        }

        function applyProperty(property, value) {
            if (!state.selectedElement) return;

            // Track change type for undo
            const changeType = property === 'text' ? 'text' : 'style';
            saveState(changeType);

            if (property === 'text') {
                state.selectedElement.textContent = value;
            } else {
                state.selectedElement.style[property] = value;
            }

            // Rescan document colors when color properties change
            if (property === 'color' || property === 'backgroundColor') {
                debounce(() => scanDocumentColors(), 500)();
            }
        }

        // =========================================================================
        // Resize & Move System
        // =========================================================================

        function detectElementConstraints(element) {
            const doc = element.ownerDocument;
            const computed = doc.defaultView.getComputedStyle(element);
            const parent = element.parentElement;
            const parentComputed = parent ? doc.defaultView.getComputedStyle(parent) : null;

            const constraints = {
                isConstrained: false,
                constraintReason: null,
                isFlexChild: false,
                isGridChild: false,
                hasAutoWidth: false,
                hasAutoHeight: false,
                isPositioned: false,
                positionType: computed.position
            };

            // Check if parent is flex or grid
            if (parentComputed) {
                if (parentComputed.display === 'flex' || parentComputed.display === 'inline-flex') {
                    constraints.isFlexChild = true;
                    constraints.isConstrained = true;
                    constraints.constraintReason = 'Flex child - size controlled by parent';
                }
                if (parentComputed.display === 'grid' || parentComputed.display === 'inline-grid') {
                    constraints.isGridChild = true;
                    constraints.isConstrained = true;
                    constraints.constraintReason = 'Grid child - size controlled by parent';
                }
            }

            // Check for auto sizing
            const inlineWidth = element.style.width;
            const inlineHeight = element.style.height;

            if (!inlineWidth || inlineWidth === 'auto' || inlineWidth === '') {
                constraints.hasAutoWidth = true;
            }
            if (!inlineHeight || inlineHeight === 'auto' || inlineHeight === '') {
                constraints.hasAutoHeight = true;
            }

            // If both auto and constrained, that's a constraint
            if ((constraints.hasAutoWidth || constraints.hasAutoHeight) &&
                (constraints.isFlexChild || constraints.isGridChild)) {
                constraints.isConstrained = true;
            }

            // Check position for movability
            const position = computed.position;
            constraints.isPositioned = (position === 'absolute' || position === 'relative' || position === 'fixed');

            return constraints;
        }

        function updateResizeOverlay() {
            if (!state.selectedElement || state.previewMode || state.selectedElements.length > 1) {
                elements.resizeOverlay.classList.remove('active');
                return;
            }

            const element = state.selectedElement;
            const frameRect = elements.previewFrame.getBoundingClientRect();
            const canvasRect = elements.canvasWrapper.getBoundingClientRect();

            // Get element rect relative to iframe content
            const elementRect = element.getBoundingClientRect();

            // Calculate position relative to canvas wrapper
            const left = (elementRect.left - frameRect.left) * state.zoom +
                        (frameRect.left - canvasRect.left);
            const top = (elementRect.top - frameRect.top) * state.zoom +
                       (frameRect.top - canvasRect.top);
            const width = elementRect.width * state.zoom;
            const height = elementRect.height * state.zoom;

            // Update overlay position
            elements.resizeOverlay.style.left = left + 'px';
            elements.resizeOverlay.style.top = top + 'px';

            elements.resizeBox.style.width = width + 'px';
            elements.resizeBox.style.height = height + 'px';

            // Detect constraints
            state.elementConstraints = detectElementConstraints(element);

            // Update constrained state
            if (state.elementConstraints.isConstrained) {
                elements.resizeBox.classList.add('constrained');
                elements.constraintTooltip.textContent = state.elementConstraints.constraintReason || 'Size controlled by parent';
            } else {
                elements.resizeBox.classList.remove('constrained');
            }

            // Update movable state
            if (state.elementConstraints.isPositioned) {
                elements.resizeBox.classList.add('movable');
                elements.resizeBox.classList.remove('static-element');
                elements.positionHint.style.display = 'none';
            } else {
                elements.resizeBox.classList.remove('movable');
                elements.resizeBox.classList.add('static-element');
            }

            // Update dimensions display
            const actualWidth = Math.round(elementRect.width);
            const actualHeight = Math.round(elementRect.height);
            elements.resizeDimensions.textContent = actualWidth + ' Ã— ' + actualHeight;

            elements.resizeOverlay.classList.add('active');
        }

        function startResize(e, handle) {
            if (state.elementConstraints?.isConstrained && !e.altKey) {
                showToast('Element size is controlled by parent layout', 'warning');
                return;
            }

            e.preventDefault();
            e.stopPropagation();

            const element = state.selectedElement;
            const rect = element.getBoundingClientRect();

            state.isResizing = true;
            state.resizeHandle = handle;
            state.resizeStartX = e.clientX;
            state.resizeStartY = e.clientY;
            state.resizeStartWidth = rect.width;
            state.resizeStartHeight = rect.height;
            state.resizeStartLeft = parseFloat(element.style.left) || 0;
            state.resizeStartTop = parseFloat(element.style.top) || 0;
            state.resizeAspectRatio = rect.width / rect.height;
            state.resizeShiftKey = e.shiftKey;

            elements.resizeOverlay.classList.add('resizing');
            document.body.style.cursor = getComputedStyle(e.target).cursor;

            saveState('resize');
        }

        function doResize(e) {
            if (!state.isResizing || !state.selectedElement) return;

            const element = state.selectedElement;
            const deltaX = (e.clientX - state.resizeStartX) / state.zoom;
            const deltaY = (e.clientY - state.resizeStartY) / state.zoom;

            let newWidth = state.resizeStartWidth;
            let newHeight = state.resizeStartHeight;
            let newLeft = state.resizeStartLeft;
            let newTop = state.resizeStartTop;

            const handle = state.resizeHandle;

            // Calculate new dimensions based on handle
            if (handle.includes('e')) {
                newWidth = Math.max(20, state.resizeStartWidth + deltaX);
            }
            if (handle.includes('w')) {
                newWidth = Math.max(20, state.resizeStartWidth - deltaX);
                if (state.elementConstraints?.isPositioned) {
                    newLeft = state.resizeStartLeft + deltaX;
                }
            }
            if (handle.includes('s')) {
                newHeight = Math.max(20, state.resizeStartHeight + deltaY);
            }
            if (handle.includes('n')) {
                newHeight = Math.max(20, state.resizeStartHeight - deltaY);
                if (state.elementConstraints?.isPositioned) {
                    newTop = state.resizeStartTop + deltaY;
                }
            }

            // Maintain aspect ratio if shift is held
            if (e.shiftKey) {
                if (handle === 'e' || handle === 'w') {
                    newHeight = newWidth / state.resizeAspectRatio;
                } else if (handle === 'n' || handle === 's') {
                    newWidth = newHeight * state.resizeAspectRatio;
                } else {
                    // Corner handles - use the larger change
                    const widthRatio = newWidth / state.resizeStartWidth;
                    const heightRatio = newHeight / state.resizeStartHeight;
                    if (widthRatio > heightRatio) {
                        newHeight = newWidth / state.resizeAspectRatio;
                    } else {
                        newWidth = newHeight * state.resizeAspectRatio;
                    }
                }
            }

            // Apply dimensions
            element.style.width = Math.round(newWidth) + 'px';
            element.style.height = Math.round(newHeight) + 'px';

            if (state.elementConstraints?.isPositioned && (handle.includes('w') || handle.includes('n'))) {
                element.style.left = Math.round(newLeft) + 'px';
                element.style.top = Math.round(newTop) + 'px';
            }

            // Update dimension display
            elements.resizeDimensions.textContent = Math.round(newWidth) + ' Ã— ' + Math.round(newHeight);

            // Update overlay position
            updateResizeOverlay();
        }

        function endResize() {
            if (!state.isResizing) return;

            state.isResizing = false;
            state.resizeHandle = null;
            elements.resizeOverlay.classList.remove('resizing');
            document.body.style.cursor = '';

            // Refresh properties panel
            if (state.selectedElement) {
                showProperties(state.selectedElement);
            }
        }

        function startMove(e) {
            if (!state.selectedElement) return;

            const constraints = state.elementConstraints;

            if (!constraints?.isPositioned) {
                // Show hint for static elements
                elements.positionHint.style.opacity = '1';
                setTimeout(() => {
                    elements.positionHint.style.opacity = '0';
                }, 2000);
                return;
            }

            e.preventDefault();
            e.stopPropagation();

            const element = state.selectedElement;
            const computed = element.ownerDocument.defaultView.getComputedStyle(element);

            state.isMoving = true;
            state.resizeStartX = e.clientX;
            state.resizeStartY = e.clientY;
            state.resizeStartLeft = parseFloat(computed.left) || 0;
            state.resizeStartTop = parseFloat(computed.top) || 0;

            elements.resizeOverlay.classList.add('moving');
            document.body.style.cursor = 'move';

            saveState('move');
        }

        function doMove(e) {
            if (!state.isMoving || !state.selectedElement) return;

            const element = state.selectedElement;
            const deltaX = (e.clientX - state.resizeStartX) / state.zoom;
            const deltaY = (e.clientY - state.resizeStartY) / state.zoom;

            const newLeft = state.resizeStartLeft + deltaX;
            const newTop = state.resizeStartTop + deltaY;

            element.style.left = Math.round(newLeft) + 'px';
            element.style.top = Math.round(newTop) + 'px';

            // Update dimension display to show position
            elements.resizeDimensions.textContent = 'x: ' + Math.round(newLeft) + ', y: ' + Math.round(newTop);

            updateResizeOverlay();
        }

        function endMove() {
            if (!state.isMoving) return;

            state.isMoving = false;
            elements.resizeOverlay.classList.remove('moving');
            document.body.style.cursor = '';

            if (state.selectedElement) {
                showProperties(state.selectedElement);
            }
        }

        function selectParentElement() {
            if (!state.selectedElement || !state.selectedPath || state.selectedPath.length <= 1) {
                showToast('No parent element to select', 'info');
                return;
            }

            const parentPath = state.selectedPath.slice(0, -1);
            selectElementByPath(parentPath);
        }

        // Initialize resize overlay event listeners
        function initResizeOverlay() {
            // Handle resize handle drag
            elements.resizeBox.querySelectorAll('.resize-handle').forEach(handle => {
                handle.addEventListener('mousedown', (e) => {
                    startResize(e, handle.dataset.handle);
                });
            });

            // Handle element body drag for moving
            elements.resizeBox.addEventListener('mousedown', (e) => {
                // Only if clicking on the box itself, not handles
                if (e.target === elements.resizeBox && state.elementConstraints?.isPositioned) {
                    startMove(e);
                } else if (e.target === elements.resizeBox && !state.elementConstraints?.isPositioned) {
                    // Show position hint for static elements
                    elements.positionHint.style.opacity = '1';
                    setTimeout(() => {
                        elements.positionHint.style.opacity = '0';
                    }, 2000);
                }
            });

            // Handle constraint tooltip click
            elements.constraintTooltip.addEventListener('click', (e) => {
                e.stopPropagation();
                selectParentElement();
            });

            // Global mouse move/up for resize and move
            document.addEventListener('mousemove', (e) => {
                if (state.isResizing) {
                    doResize(e);
                } else if (state.isMoving) {
                    doMove(e);
                }
            });

            document.addEventListener('mouseup', () => {
                endResize();
                endMove();
            });

            // Update overlay on scroll/resize
            elements.canvasViewport.addEventListener('scroll', updateResizeOverlay);
            window.addEventListener('resize', debounce(updateResizeOverlay, 100));
        }

        // =========================================================================
        // Visual Spacing Editor
        // =========================================================================

        function parseSpacingValue(value) {
            if (!value || value === 'auto') return 0;
            const num = parseFloat(value);
            return isNaN(num) ? 0 : num;
        }

        function updateSpacingOverlay() {
            if (!state.selectedElement || state.previewMode || state.selectedElements.length > 1) {
                elements.spacingOverlay.classList.remove('active');
                return;
            }

            const element = state.selectedElement;
            const doc = element.ownerDocument;
            const computed = doc.defaultView.getComputedStyle(element);

            const frameRect = elements.previewFrame.getBoundingClientRect();
            const canvasRect = elements.canvasWrapper.getBoundingClientRect();
            const elementRect = element.getBoundingClientRect();

            // Get spacing values
            const margin = {
                top: parseSpacingValue(computed.marginTop),
                right: parseSpacingValue(computed.marginRight),
                bottom: parseSpacingValue(computed.marginBottom),
                left: parseSpacingValue(computed.marginLeft)
            };

            const padding = {
                top: parseSpacingValue(computed.paddingTop),
                right: parseSpacingValue(computed.paddingRight),
                bottom: parseSpacingValue(computed.paddingBottom),
                left: parseSpacingValue(computed.paddingLeft)
            };

            // Calculate position relative to canvas wrapper (including zoom)
            const zoom = state.zoom;
            const baseLeft = (elementRect.left - frameRect.left) * zoom + (frameRect.left - canvasRect.left);
            const baseTop = (elementRect.top - frameRect.top) * zoom + (frameRect.top - canvasRect.top);
            const width = elementRect.width * zoom;
            const height = elementRect.height * zoom;

            // Scale margins
            const scaledMargin = {
                top: margin.top * zoom,
                right: margin.right * zoom,
                bottom: margin.bottom * zoom,
                left: margin.left * zoom
            };

            const scaledPadding = {
                top: padding.top * zoom,
                right: padding.right * zoom,
                bottom: padding.bottom * zoom,
                left: padding.left * zoom
            };

            // Position the overlay to include margins
            elements.spacingOverlay.style.left = (baseLeft - scaledMargin.left) + 'px';
            elements.spacingOverlay.style.top = (baseTop - scaledMargin.top) + 'px';
            elements.spacingOverlay.style.width = (width + scaledMargin.left + scaledMargin.right) + 'px';
            elements.spacingOverlay.style.height = (height + scaledMargin.top + scaledMargin.bottom) + 'px';

            // Position margin boxes
            elements.spacingMarginTop.style.height = scaledMargin.top + 'px';
            elements.spacingMarginTop.style.left = scaledMargin.left + 'px';
            elements.spacingMarginTop.style.right = scaledMargin.right + 'px';
            elements.spacingMarginTop.style.display = scaledMargin.top > 0 ? 'block' : 'none';

            elements.spacingMarginRight.style.width = scaledMargin.right + 'px';
            elements.spacingMarginRight.style.top = scaledMargin.top + 'px';
            elements.spacingMarginRight.style.bottom = scaledMargin.bottom + 'px';
            elements.spacingMarginRight.style.display = scaledMargin.right > 0 ? 'block' : 'none';

            elements.spacingMarginBottom.style.height = scaledMargin.bottom + 'px';
            elements.spacingMarginBottom.style.left = scaledMargin.left + 'px';
            elements.spacingMarginBottom.style.right = scaledMargin.right + 'px';
            elements.spacingMarginBottom.style.display = scaledMargin.bottom > 0 ? 'block' : 'none';

            elements.spacingMarginLeft.style.width = scaledMargin.left + 'px';
            elements.spacingMarginLeft.style.top = scaledMargin.top + 'px';
            elements.spacingMarginLeft.style.bottom = scaledMargin.bottom + 'px';
            elements.spacingMarginLeft.style.display = scaledMargin.left > 0 ? 'block' : 'none';

            // Position padding boxes (inside the element)
            const paddingLeft = scaledMargin.left;
            const paddingTop = scaledMargin.top;

            elements.spacingPaddingTop.style.left = paddingLeft + 'px';
            elements.spacingPaddingTop.style.right = scaledMargin.right + 'px';
            elements.spacingPaddingTop.style.top = paddingTop + 'px';
            elements.spacingPaddingTop.style.height = scaledPadding.top + 'px';
            elements.spacingPaddingTop.style.display = scaledPadding.top > 0 ? 'block' : 'none';

            elements.spacingPaddingRight.style.right = scaledMargin.right + 'px';
            elements.spacingPaddingRight.style.top = paddingTop + scaledPadding.top + 'px';
            elements.spacingPaddingRight.style.bottom = scaledMargin.bottom + scaledPadding.bottom + 'px';
            elements.spacingPaddingRight.style.width = scaledPadding.right + 'px';
            elements.spacingPaddingRight.style.display = scaledPadding.right > 0 ? 'block' : 'none';

            elements.spacingPaddingBottom.style.left = paddingLeft + 'px';
            elements.spacingPaddingBottom.style.right = scaledMargin.right + 'px';
            elements.spacingPaddingBottom.style.bottom = scaledMargin.bottom + 'px';
            elements.spacingPaddingBottom.style.height = scaledPadding.bottom + 'px';
            elements.spacingPaddingBottom.style.display = scaledPadding.bottom > 0 ? 'block' : 'none';

            elements.spacingPaddingLeft.style.left = paddingLeft + 'px';
            elements.spacingPaddingLeft.style.top = paddingTop + scaledPadding.top + 'px';
            elements.spacingPaddingLeft.style.bottom = scaledMargin.bottom + scaledPadding.bottom + 'px';
            elements.spacingPaddingLeft.style.width = scaledPadding.left + 'px';
            elements.spacingPaddingLeft.style.display = scaledPadding.left > 0 ? 'block' : 'none';

            // Position content box
            elements.spacingContent.style.left = (scaledMargin.left + scaledPadding.left) + 'px';
            elements.spacingContent.style.top = (scaledMargin.top + scaledPadding.top) + 'px';
            elements.spacingContent.style.right = (scaledMargin.right + scaledPadding.right) + 'px';
            elements.spacingContent.style.bottom = (scaledMargin.bottom + scaledPadding.bottom) + 'px';

            // Update labels
            elements.marginTopLabel.textContent = Math.round(margin.top);
            elements.marginRightLabel.textContent = Math.round(margin.right);
            elements.marginBottomLabel.textContent = Math.round(margin.bottom);
            elements.marginLeftLabel.textContent = Math.round(margin.left);

            elements.paddingTopLabel.textContent = Math.round(padding.top);
            elements.paddingRightLabel.textContent = Math.round(padding.right);
            elements.paddingBottomLabel.textContent = Math.round(padding.bottom);
            elements.paddingLeftLabel.textContent = Math.round(padding.left);

            // Hide labels for zero values
            elements.marginTopLabel.style.display = margin.top > 0 ? 'block' : 'none';
            elements.marginRightLabel.style.display = margin.right > 0 ? 'block' : 'none';
            elements.marginBottomLabel.style.display = margin.bottom > 0 ? 'block' : 'none';
            elements.marginLeftLabel.style.display = margin.left > 0 ? 'block' : 'none';

            elements.paddingTopLabel.style.display = padding.top > 0 ? 'block' : 'none';
            elements.paddingRightLabel.style.display = padding.right > 0 ? 'block' : 'none';
            elements.paddingBottomLabel.style.display = padding.bottom > 0 ? 'block' : 'none';
            elements.paddingLeftLabel.style.display = padding.left > 0 ? 'block' : 'none';

            // Position draggable edges
            const edges = elements.spacingOverlay.querySelectorAll('.spacing-edge');
            edges.forEach(edge => {
                const type = edge.dataset.type;
                const side = edge.dataset.side;

                if (type === 'margin') {
                    if (side === 'top') {
                        edge.style.top = '0';
                        edge.style.left = scaledMargin.left + 'px';
                        edge.style.right = scaledMargin.right + 'px';
                    } else if (side === 'bottom') {
                        edge.style.bottom = '0';
                        edge.style.left = scaledMargin.left + 'px';
                        edge.style.right = scaledMargin.right + 'px';
                    } else if (side === 'left') {
                        edge.style.left = '0';
                        edge.style.top = scaledMargin.top + 'px';
                        edge.style.bottom = scaledMargin.bottom + 'px';
                    } else if (side === 'right') {
                        edge.style.right = '0';
                        edge.style.top = scaledMargin.top + 'px';
                        edge.style.bottom = scaledMargin.bottom + 'px';
                    }
                } else if (type === 'padding') {
                    if (side === 'top') {
                        edge.style.top = scaledMargin.top + 'px';
                        edge.style.left = (scaledMargin.left + scaledPadding.left) + 'px';
                        edge.style.right = (scaledMargin.right + scaledPadding.right) + 'px';
                    } else if (side === 'bottom') {
                        edge.style.bottom = scaledMargin.bottom + 'px';
                        edge.style.left = (scaledMargin.left + scaledPadding.left) + 'px';
                        edge.style.right = (scaledMargin.right + scaledPadding.right) + 'px';
                    } else if (side === 'left') {
                        edge.style.left = scaledMargin.left + 'px';
                        edge.style.top = (scaledMargin.top + scaledPadding.top) + 'px';
                        edge.style.bottom = (scaledMargin.bottom + scaledPadding.bottom) + 'px';
                    } else if (side === 'right') {
                        edge.style.right = scaledMargin.right + 'px';
                        edge.style.top = (scaledMargin.top + scaledPadding.top) + 'px';
                        edge.style.bottom = (scaledMargin.bottom + scaledPadding.bottom) + 'px';
                    }
                }
            });

            elements.spacingOverlay.classList.add('active');
        }

        function startSpacingDrag(e, type, side) {
            if (!state.selectedElement) return;

            e.preventDefault();
            e.stopPropagation();

            const element = state.selectedElement;
            const computed = element.ownerDocument.defaultView.getComputedStyle(element);

            // Get current value
            const propName = type + side.charAt(0).toUpperCase() + side.slice(1);
            const currentValue = parseSpacingValue(computed[propName]);

            state.isSpacingDrag = true;
            state.spacingDragType = type;
            state.spacingDragSide = side;
            state.spacingDragStartX = e.clientX;
            state.spacingDragStartY = e.clientY;
            state.spacingDragStartValue = currentValue;
            state.spacingShiftKey = e.shiftKey;

            // Add active class to edge
            const edge = e.target;
            edge.classList.add('active');

            // Show editing state
            elements.spacingOverlay.classList.add('editing');

            // Show drag value
            elements.spacingDragValue.classList.add('visible');
            elements.spacingDragValue.textContent = Math.round(currentValue) + 'px';
            elements.spacingDragValue.style.left = (e.clientX + 15) + 'px';
            elements.spacingDragValue.style.top = (e.clientY - 10) + 'px';

            document.body.style.cursor = side === 'top' || side === 'bottom' ? 'ns-resize' : 'ew-resize';

            saveState('spacing');
        }

        function doSpacingDrag(e) {
            if (!state.isSpacingDrag || !state.selectedElement) return;

            const element = state.selectedElement;
            const side = state.spacingDragSide;
            const type = state.spacingDragType;

            // Calculate delta based on side
            let delta;
            if (side === 'top') {
                delta = (state.spacingDragStartY - e.clientY) / state.zoom;
            } else if (side === 'bottom') {
                delta = (e.clientY - state.spacingDragStartY) / state.zoom;
            } else if (side === 'left') {
                delta = (state.spacingDragStartX - e.clientX) / state.zoom;
            } else if (side === 'right') {
                delta = (e.clientX - state.spacingDragStartX) / state.zoom;
            }

            // Calculate new value (minimum 0)
            let newValue = Math.max(0, Math.round(state.spacingDragStartValue + delta));

            // Snap to grid (8px)
            if (!e.altKey) {
                newValue = Math.round(newValue / 4) * 4;
            }

            // Get property name
            const propName = type + side.charAt(0).toUpperCase() + side.slice(1);

            // Apply to element
            element.style[propName] = newValue + 'px';

            // If shift is held, apply to opposite side too (symmetric)
            if (e.shiftKey) {
                const oppositeSide = {
                    top: 'bottom',
                    bottom: 'top',
                    left: 'right',
                    right: 'left'
                }[side];
                const oppositeProp = type + oppositeSide.charAt(0).toUpperCase() + oppositeSide.slice(1);
                element.style[oppositeProp] = newValue + 'px';
            }

            // Update drag value display
            elements.spacingDragValue.textContent = newValue + 'px';
            elements.spacingDragValue.style.left = (e.clientX + 15) + 'px';
            elements.spacingDragValue.style.top = (e.clientY - 10) + 'px';

            // Update overlays
            updateSpacingOverlay();
            updateResizeOverlay();
        }

        function endSpacingDrag() {
            if (!state.isSpacingDrag) return;

            state.isSpacingDrag = false;
            state.spacingDragType = null;
            state.spacingDragSide = null;

            // Remove active class from all edges
            elements.spacingOverlay.querySelectorAll('.spacing-edge.active').forEach(edge => {
                edge.classList.remove('active');
            });

            // Hide editing state
            elements.spacingOverlay.classList.remove('editing');

            // Hide drag value
            elements.spacingDragValue.classList.remove('visible');

            document.body.style.cursor = '';

            // Refresh properties panel
            if (state.selectedElement) {
                showProperties(state.selectedElement);
            }
        }

        function applySpacingPreset(value, type, side) {
            if (!state.selectedElement) return;

            saveState('spacing');

            const element = state.selectedElement;

            if (type && side) {
                // Apply to specific side
                const propName = type + side.charAt(0).toUpperCase() + side.slice(1);
                element.style[propName] = value + 'px';
            } else if (state.spacingDragType && state.spacingDragSide) {
                // Apply to last dragged side
                const propName = state.spacingDragType + state.spacingDragSide.charAt(0).toUpperCase() + state.spacingDragSide.slice(1);
                element.style[propName] = value + 'px';
            }

            updateSpacingOverlay();
            updateResizeOverlay();
            showProperties(element);
        }

        function initSpacingOverlay() {
            // Handle edge drag start
            const edges = elements.spacingOverlay.querySelectorAll('.spacing-edge');
            edges.forEach(edge => {
                edge.addEventListener('mousedown', (e) => {
                    startSpacingDrag(e, edge.dataset.type, edge.dataset.side);
                });
            });

            // Handle preset clicks
            elements.spacingPresets.querySelectorAll('.spacing-preset').forEach(preset => {
                preset.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const value = parseInt(preset.dataset.value);
                    applySpacingPreset(value);
                });
            });

            // Global mouse move/up for spacing drag
            document.addEventListener('mousemove', (e) => {
                if (state.isSpacingDrag) {
                    doSpacingDrag(e);
                }
            });

            document.addEventListener('mouseup', () => {
                endSpacingDrag();
            });

            // Update overlay on scroll/resize
            elements.canvasViewport.addEventListener('scroll', updateSpacingOverlay);
            window.addEventListener('resize', debounce(updateSpacingOverlay, 100));
        }

        // =========================================================================
        // Event Listeners
        // =========================================================================

        // Quick actions toolbar events
        elements.quickActions.addEventListener('click', (e) => {
            const btn = e.target.closest('.qa-btn');
            if (btn && btn.dataset.action) {
                handleQuickAction(btn.dataset.action);
            }
            const dropdownItem = e.target.closest('.qa-dropdown-item');
            if (dropdownItem && dropdownItem.dataset.action) {
                handleQuickAction(dropdownItem.dataset.action);
            }
        });

        // Close layout dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!elements.qaLayoutDropdown.contains(e.target)) {
                closeLayoutDropdown();
            }
        });

        // Update quick actions position on scroll/zoom
        elements.canvasViewport.addEventListener('scroll', () => {
            if (state.selectedElement && !state.previewMode) {
                positionQuickActions();
            }
        });

        // Context menu events
        elements.contextMenu.addEventListener('click', (e) => {
            const item = e.target.closest('.context-menu-item');
            if (item && !item.classList.contains('disabled')) {
                handleContextMenuAction(item.dataset.action);
            }
        });

        // Close context menu on click outside or escape
        document.addEventListener('click', (e) => {
            if (!elements.contextMenu.contains(e.target)) {
                hideContextMenu();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                hideContextMenu();
            }
        }, true);

        // Close context menu on scroll
        document.addEventListener('scroll', hideContextMenu, true);

        elements.btnOpen.addEventListener('click', () => elements.fileInput.click());
        elements.fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) handleFile(e.target.files[0]);
        });

        // Sample button
        elements.btnSample.addEventListener('click', loadSampleHtml);

        // Tree search
        elements.treeSearchInput.addEventListener('input', (e) => {
            if (state.searchMode === 'elements') {
                filterElementTree(e.target.value);
            } else {
                searchTextContent(e.target.value);
            }
        });

        elements.treeSearchClear.addEventListener('click', clearTreeSearch);

        elements.treeSearchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (elements.treeSearchInput.value) {
                    clearTreeSearch();
                    e.stopPropagation();
                }
            }
        });

        // Search mode toggle
        elements.searchModeElements.addEventListener('click', () => setSearchMode('elements'));
        elements.searchModeText.addEventListener('click', () => setSearchMode('text'));

        // Drop zone - click to open file picker
        elements.dropZone.addEventListener('click', () => elements.fileInput.click());

        elements.dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.dropZone.classList.add('dragover');
        });

        elements.dropZone.addEventListener('dragleave', () => {
            elements.dropZone.classList.remove('dragover');
        });

        elements.dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.dropZone.classList.remove('dragover');
            if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
        });

        // Insert menu
        elements.btnInsert.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleInsertMenu();
        });

        elements.insertMenu.addEventListener('click', (e) => {
            const item = e.target.closest('.dropdown-item');
            if (item) {
                const tagName = item.dataset.tag;
                const templateName = item.dataset.template;
                if (templateName) {
                    insertTemplate(templateName);
                } else if (tagName) {
                    insertElement(tagName);
                }
            }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!elements.insertDropdown.contains(e.target)) {
                closeInsertMenu();
            }
        });

        elements.btnUndo.addEventListener('click', undo);
        elements.btnRedo.addEventListener('click', redo);

        // Zoom controls
        elements.btnZoomIn.addEventListener('click', () => zoomIn());
        elements.btnZoomOut.addEventListener('click', () => zoomOut());
        elements.btnFit.addEventListener('click', fitToScreen);
        elements.zoomLevel.addEventListener('click', resetZoom);

        // Wheel zoom
        elements.canvasArea.addEventListener('wheel', handleWheel, { passive: false });

        // Space + drag pan
        document.addEventListener('keydown', (e) => {
            const activeTag = document.activeElement.tagName;
            const isInputFocused = activeTag === 'INPUT' || activeTag === 'TEXTAREA';

            if (e.code === 'Space' && !e.repeat && !isInputFocused) {
                state.isSpaceDown = true;
                elements.canvasArea.classList.add('panning');
                e.preventDefault();
            }

            // Delete element with Backspace or Delete key
            if ((e.key === 'Backspace' || e.key === 'Delete') && !isInputFocused) {
                // Also check if we're editing inside the iframe
                const frame = elements.previewFrame;
                const frameDoc = frame.contentDocument || frame.contentWindow.document;
                const frameActive = frameDoc.activeElement;
                const isFrameEditing = frameActive && frameActive.isContentEditable;

                if (!isFrameEditing && state.selectedElement) {
                    e.preventDefault();
                    deleteSelectedElement();
                }
            }

            // Zoom with +/- keys
            if ((e.key === '=' || e.key === '+') && !isInputFocused && state.documentLoaded) {
                e.preventDefault();
                zoomIn();
            }
            if (e.key === '-' && !isInputFocused && state.documentLoaded) {
                e.preventDefault();
                zoomOut();
            }
            // Zoom reset with 0 key
            if (e.key === '0' && !isInputFocused && state.documentLoaded) {
                e.preventDefault();
                resetZoom();
            }
            // Fit to screen with 1 key
            if (e.key === '1' && !isInputFocused && state.documentLoaded) {
                e.preventDefault();
                fitToScreen();
            }

            // Grid toggle with G key
            if (e.key === 'g' && !isInputFocused && state.documentLoaded) {
                e.preventDefault();
                toggleGrid();
            }

            // Preview/Edit mode toggle
            if (e.key === 'p' && !isInputFocused && state.documentLoaded) {
                e.preventDefault();
                togglePreviewMode();
            }

            // Escape to deselect
            if (e.key === 'Escape' && !isInputFocused) {
                e.preventDefault();
                clearSelection();
            }

            // Arrow keys to nudge position (with Shift for larger increments)
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key) && !isInputFocused) {
                const frame = elements.previewFrame;
                const frameDoc = frame.contentDocument || frame.contentWindow.document;
                const frameActive = frameDoc.activeElement;
                const isFrameEditing = frameActive && frameActive.isContentEditable;

                if (!isFrameEditing && state.selectedElement) {
                    e.preventDefault();
                    const step = e.shiftKey ? 10 : 1;
                    switch (e.key) {
                        case 'ArrowUp':
                            nudgeSelectedElements(0, -step);
                            break;
                        case 'ArrowDown':
                            nudgeSelectedElements(0, step);
                            break;
                        case 'ArrowLeft':
                            nudgeSelectedElements(-step, 0);
                            break;
                        case 'ArrowRight':
                            nudgeSelectedElements(step, 0);
                            break;
                    }
                }
            }

            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') {
                    e.preventDefault();
                    if (e.shiftKey) redo();
                    else undo();
                }
                if (e.key === 'y') {
                    e.preventDefault();
                    redo();
                }
                if (e.key === 'c' && !isInputFocused) {
                    e.preventDefault();
                    if (e.shiftKey) {
                        copyStyle();
                    } else {
                        copySelectedElements();
                    }
                }
                if (e.key === 'v' && !isInputFocused) {
                    e.preventDefault();
                    if (e.shiftKey) {
                        pasteStyle();
                    } else {
                        pasteElements();
                    }
                }
                // Ctrl+D - duplicate element as sibling below
                if (e.key === 'd' && !isInputFocused) {
                    e.preventDefault();
                    duplicateSelectedElement();
                }
                if (e.key === '0') {
                    e.preventDefault();
                    fitToScreen();
                }
                if (e.key === '=' || e.key === '+') {
                    e.preventDefault();
                    zoomIn();
                }
                if (e.key === '-') {
                    e.preventDefault();
                    zoomOut();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                state.isSpaceDown = false;
                if (!state.isPanning) {
                    elements.canvasArea.classList.remove('panning');
                }
            }
        });

        elements.canvasArea.addEventListener('mousedown', startPan);
        document.addEventListener('mousemove', doPan);
        document.addEventListener('mouseup', () => {
            endPan();
            if (!state.isSpaceDown) {
                elements.canvasArea.classList.remove('panning');
            }
        });

        elements.btnExport.addEventListener('click', exportHtml);

        elements.propText.addEventListener('input', (e) => applyProperty('text', e.target.value));
        elements.propFontSize.addEventListener('change', (e) => {
            if (e.target.value === 'custom') {
                // Prompt for custom value
                const currentSize = state.selectedElement ?
                    state.selectedElement.ownerDocument.defaultView.getComputedStyle(state.selectedElement).fontSize : '16px';
                const customValue = prompt('Enter custom font size (e.g., 20px, 1.5rem, 2em):', currentSize);
                if (customValue && customValue.trim()) {
                    applyProperty('fontSize', customValue.trim());
                    // Update the custom option text
                    const customOption = e.target.querySelector('option[value="custom"]');
                    if (customOption) {
                        customOption.textContent = 'Custom (' + customValue.trim() + ')';
                    }
                } else {
                    // Revert to previous selection if cancelled
                    if (state.selectedElement) {
                        showProperties(state.selectedElement);
                    }
                }
            } else {
                applyProperty('fontSize', e.target.value);
            }
        });

        // Style clipboard events
        elements.styleClipboardClear.addEventListener('click', clearStyleClipboard);

        // Font picker events
        elements.fontPickerTrigger.addEventListener('click', toggleFontPicker);

        elements.fontPickerSearch.addEventListener('input', (e) => {
            renderFontPicker(e.target.value);
        });

        elements.fontStyleBold.addEventListener('click', () => toggleFontStyle('bold'));
        elements.fontStyleItalic.addEventListener('click', () => toggleFontStyle('italic'));

        // Close font picker on click outside
        document.addEventListener('click', (e) => {
            if (state.fontPickerOpen && !elements.fontPickerWrapper.contains(e.target)) {
                closeFontPicker();
            }
        });
        elements.propFontWeight.addEventListener('change', (e) => applyProperty('fontWeight', e.target.value));
        elements.propColor.addEventListener('input', (e) => {
            const newColor = e.target.value;
            if (elements.applyAllTextColor.checked && state.lastTextColor) {
                applyColorToAllMatching(state.lastTextColor, newColor, 'color');
            } else {
                applyProperty('color', newColor);
            }
            elements.propColorValue.textContent = newColor;
        });
        elements.propTextAlign.addEventListener('change', (e) => applyProperty('textAlign', e.target.value));
        elements.propBgColor.addEventListener('input', (e) => {
            const newColor = e.target.value;
            if (elements.applyAllBgColor.checked && state.lastBgColor) {
                applyColorToAllMatching(state.lastBgColor, newColor, 'backgroundColor');
            } else {
                applyProperty('backgroundColor', newColor);
            }
            elements.propBgColorValue.textContent = newColor;
        });

        // Document colors event listeners
        elements.propColorValue.addEventListener('click', () => copyColorToClipboard(elements.propColor.value));
        elements.propBgColorValue.addEventListener('click', () => copyColorToClipboard(elements.propBgColor.value));
        elements.btnReplaceTextColor.addEventListener('click', () => openReplaceModal('text'));
        elements.btnReplaceBgColor.addEventListener('click', () => openReplaceModal('bg'));
        elements.btnCancelReplace.addEventListener('click', closeReplaceModal);
        elements.btnConfirmReplace.addEventListener('click', executeColorReplace);
        elements.replaceNewColor.addEventListener('input', updateReplacePreview);
        elements.replaceNewColorValue.addEventListener('click', () => copyColorToClipboard(elements.replaceNewColor.value));

        // Close modal on escape or click outside
        elements.colorReplaceModal.addEventListener('click', (e) => {
            if (e.target === elements.colorReplaceModal) closeReplaceModal();
        });

        elements.propMarginTop.addEventListener('change', (e) => applyProperty('marginTop', e.target.value));
        elements.propMarginRight.addEventListener('change', (e) => applyProperty('marginRight', e.target.value));
        elements.propMarginBottom.addEventListener('change', (e) => applyProperty('marginBottom', e.target.value));
        elements.propMarginLeft.addEventListener('change', (e) => applyProperty('marginLeft', e.target.value));

        elements.propPaddingTop.addEventListener('change', (e) => applyProperty('paddingTop', e.target.value));
        elements.propPaddingRight.addEventListener('change', (e) => applyProperty('paddingRight', e.target.value));
        elements.propPaddingBottom.addEventListener('change', (e) => applyProperty('paddingBottom', e.target.value));
        elements.propPaddingLeft.addEventListener('change', (e) => applyProperty('paddingLeft', e.target.value));

        elements.propWidth.addEventListener('change', (e) => applyProperty('width', e.target.value));
        elements.propHeight.addEventListener('change', (e) => applyProperty('height', e.target.value));

        // Shortcuts modal
        function showShortcutsModal() {
            elements.shortcutsModal.classList.add('visible');
        }

        function hideShortcutsModal() {
            elements.shortcutsModal.classList.remove('visible');
        }

        elements.showShortcutsLink?.addEventListener('click', showShortcutsModal);
        elements.shortcutsModalClose.addEventListener('click', hideShortcutsModal);
        elements.shortcutsModal.addEventListener('click', (e) => {
            if (e.target === elements.shortcutsModal) {
                hideShortcutsModal();
            }
        });

        // Press ? to show shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === '?' && !e.target.matches('input, textarea, [contenteditable]')) {
                e.preventDefault();
                showShortcutsModal();
            }
            if (e.key === 'Escape' && elements.shortcutsModal.classList.contains('visible')) {
                hideShortcutsModal();
            }
        });

        // Initialize theme
        initTheme();
        elements.btnTheme.addEventListener('click', toggleTheme);

        // Grid toggle
        elements.btnGrid.addEventListener('click', toggleGrid);

        // Mode toggle
        initModeToggle();

        // Viewport selector
        initViewportSelector();

        // Resize overlay
        initResizeOverlay();

        // Spacing overlay
        initSpacingOverlay();

        // First-time tooltip (shows hint on first visit)
        (function initFirstTimeTooltip() {
            const STORAGE_KEY = 'html-editor-tooltip-shown';
            if (localStorage.getItem(STORAGE_KEY)) return;

            const tooltip = document.createElement('div');
            tooltip.className = 'first-time-tooltip';
            tooltip.textContent = 'Click to select, double-click to edit text';
            elements.canvasViewport.appendChild(tooltip);

            const dismissTooltip = () => {
                tooltip.classList.add('hiding');
                localStorage.setItem(STORAGE_KEY, 'true');
                setTimeout(() => tooltip.remove(), 200);
                document.removeEventListener('click', dismissTooltip);
            };

            setTimeout(() => document.addEventListener('click', dismissTooltip), 100);
        })();

        // Initialize transform
        updateTransform();

    })();
    </script>
</body>
</html>
